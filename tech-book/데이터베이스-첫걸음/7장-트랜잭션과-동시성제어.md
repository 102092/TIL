### 트랜잭션이란?

- 쿼리의 처리 단위를 의미함.
- 다시 말해서 복수 쿼리를 한 단위로 묶은 것을 의미한다.



### 트랜젹션의 특성

1. 원자성
2. 일관성
3. 고립성 , 격리성
4. 지속성



#### 원자성

- 데이터의 변경(INSERT, DELETE, UPDATE)를 수반하는 일련의 데이터 조작이 **전부 성공할지 전부 실패할지**를 보증하는 구조.
- 즉 결과적으로 성공 아니면 실패다!

- 어떤 일련의 과정을 모두 성공해야, `COMMIT` 을 실행하여 확정함.
  - 이 과정 중에 문제가 있다면, `ROLLBACK` 을 실행하여 일정 상태 직전으로 돌아간다.



#### 일관성

- 데이터베이스 오브젝트에 대해 정합성 제약을 추가하는 것.
- 일련의 데이터 조작 전 후에는 **그 상태** 를 유지한다는 것을 보증한다.



#### 고립성 혹은 격리성

- 데이터 조작을 복수 사용자가 **동시에 실행해도**, *각각의 처리가 모순 없이 실행* 되는 것을 보장한다는 의미.
- 복수의 트랜잭션이 순서대로 실행되는 경우와 같은 결과를 얻을 수 있는 상태를 의미한다.
- 어떻게? 
  - 행 단위 잠금 기능을 제공한다!



#### 지속성

- 일련의 데이터 조작이 완료(COMMIT) 되면, 그 조작이 영구적으로 되어 결과를 잃지 않는 것을 의미한다.
- 이러한 특성은 시스템이 정상일 때뿐만 아니라, 장애일 경우에도 보장된다.
  - 어떻게?
  - 로그를 통해서!



### 다른 커넥션에서!

- DDL(CREATE TABLE...) 실행 시 암묵적인 커밋이 발생함.

- 오토 커밋 설정

  - 트랜잭션의 시작에 대해 명시적으로 지정되지 않으면, 

  1. 하나의 SQL문을 트랜젹으로 구분하던가
  2. 사용자가 COMMIT 또는 ROLLBACK을 실행하기 전까지가 하나의 트랜잭션으로 간주 된다.



### MVCC

- Muti Versioning Concurrency Control
  - 읽기를 수행할 경우, 갱신 중이라도 블록되지 않는다.
  - 갱신과 갱신은 **나중에 온 트랜잭션이 잠금을 획득**하려고 할 때, 블록된다. 일정 시간 기다리면서 그 사이에 잠금을 획득할 수 없는 경우에는 *잠금 타임아웃*이 됨.

- MySQL의 트랜잭션 격리 수준의 기본값은 **반복 읽기**
- 반복읽기는 최초 쿼리를 실행 시점에, 커밋한 데이터를 읽어 들임.
  - 같은 쿼리를 복수 회 실행하면, 최초 읽은 내용의 결과 세트가 반횐됨.
  - 복수 회 쿼리 실행 사이에, **다른 트랜잭션이 커밋 했어도 그 내용은 반영되지 않음**.
- 커밋된 읽기는 쿼리를 실행시점에서 커밋한 데이터를 읽음.
  - 복수 회 쿼리 실행 사이에, **다른 트랜잭션이 커밋하면, 이 경우 커밋된 데이터를 읽음**.

- 갱신을 수행하는 트랜잭션 자신
  - 트랜잭션 격리 수준 혹은 COMMIT/ROLLBACK에 상관 없이, 자신이 수행했던 갱신을 즉시 볼 수 있음!



### 잠금 타임아웃, 교착상태

#### 잠금타임아웃이란?

- 갱신, 갱신이 부딪치는 경우, 나중에 온 갱신이 **잠금 대기 상태** 가됨.

- 잠금 해제 를 기다리고 있는 쪽에서는 얼마나 기다릴지 설정할 수 있음.
- 잠금 대기로 타임아웃이 발생하면, 오류가 발생한 쿼리가 롤백됨(기본)
  - 트랜잭션 전체를 롤백하고 싶다면.. 추가적인 설정이 필요하다.



#### 교착 상태의 빈도를 낮추는 대책은?

- DBMS에서
  - 트랜잭션을 자주 커밋함. 즉 트랜잭션의 단위를 작게 만들어서, 교착 상태가 발생할 가능성을 낮춤.
  - 잠금 정도를 작게하던가
  - 정해진 순서대로 테이블, 행에 액세스하게 하도록, 겹치지 않게
- MySQL에서
  - 인덱스를 이용하여, 쿼리가 이용하도록 만듬.



### 해서는 안되는 트랜잭션

- 오토커밋

  - 오토머시은 쿼리 단위로 커밋함.
  - 이러면 커밋 부하가 너무 높당.

- 긴 트랜잭션

  - 교착상태가 발생한 가능성이 높다.

- 대량 처리를 위해 한 개의 트랜잭션이 담당하는 것

  - 문제가 발생하면 롤백하기 위해서, 대량의 로그를 유지해야함.
  - 많이 자원 소모

- 아무것도 하지 않는 트랜잭션

  - 이럴 경우, 로그가 계속 유지됨.

- 트랜잭션 중 대화처리를 넣는경우

  - 끝없이 사용자의 처리를 기다리는 경우가 생기면, 효율이 저하됨.
  - 이러한 처리는 트랜잭션에 넣지 않는다.

- 처리 능력 이상의 트랜잭션 수.

  