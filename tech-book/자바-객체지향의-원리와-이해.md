> 참고

- https://wikibook.co.kr/java-oop-for-spring/



> 목적

- 객체 지향에 대한 정리
- 자바, 스프링에 대한 전반적인 참고
- 이해가 안되도 계속 잡고있지 말자.
- 나만의 비유로 정리하자.



> 목차





## 1부

- 기계어 : 컴퓨터(기계) 만 읽을 수 있는, 이해할 수 있는 언어. 0,1로 이루어져 있음.
- 어셈블리어 : 기계어에서 벗어나, 인간도 이제 나름 이해할 수 있고 읽을 수 있는 언어. 
  - 왜? 기계의 언어 중 일부를 인간의 언어로 치환하였기에 인간도 이해 할 수 있음.
  - 예전에는 사용하는 CPU 마다 사용할 수 있는 어셈블리어가 달랐다.
- C 언어 : 어떤 운영체제에서던지, 코드에 대응되는 소스 파일이 단 하나. 이 하나를 각각 운영체제 컴파일러가 자신의 CPU가 읽을 수 있도록 컴파일 해줌.
  - 포인터 극악
  - 하지만 등장한 이유는 필요성이 있었겠지. 아마도 어셈블리어로 코드 짜던 사람들에게는 축복이었을듯

- 스프링은 객체지향 위에 있는 도구.



## 2부

- JDK - 자바 개발 도구 -- 소프트웨어 개발 도구
- JRE - 자바 실행 환경 -- 운영체제
- JVM - 자바 가상 기계  -- 하드웨어, 물리적 컴퓨터를 의미.
- Java의 특징 Write Once Run AnyWhere
- Function vs Method
  - 같은 것을 표현하고, 표현하는 단어만 다름.
  - 엄밀하게 비교해보면, Method는 Class 내부에서만 존재할 수 있다는 점?

#### main() 

- 프로그램 시작 시점
- 실행되면 main stack frame이 생성되고, 가장 아래(제일 먼저) args 참조 변수(String 배열을 참조하는)가 생성됨
- `static` 영역 : 클래스 변수 , 상수 등이 생성되는 영역
- `stack` : 메서드가 올라가고, 지역 변수들이 생성됨.
- `heap` : 객체 생성 영역
- 프로그램 실행 순서
  1. JRE 가 프로그램 안에, main() 메서드가 있는 지 확인함(없으면 오류!)
  2. 있으면, JRE는 JVM 가상 머신을 실행
  3. 부팅된 JVM은 클래스 파일을 받아서, 그 파일을 실행.
  4. <u>전처리 과정이 진행</u>됨(java.lang 패키지를 static 영역에 로딩, import된 패키지, 그리고 클래스를 올림)
  5. main stack frame 이 생성되고, 참조변수 `args` 가 제일 아래 할당됨.
- Java에서 스택은 `{` 를 만나면 생기고 `}` 를 만나면 닫힌다.
- `main()` 메서드가 끝나면, 프로그램은 종료된다.



##### 변수

- 지역 변수는 스택 영역에 생성되었다가 사라지고,
- 클래스 변수는 스태틱 영역에 성생되어 , JVM이 종료될 때 까지 존재하게 되고.
- 객체의 멤버 변수는 힙에서 생성되고, 객체의 참조가 사라질 때, GC에 의해 사라지게 된다.
- <u>외부 스택 프레임에서, 내부 스택 프레임의 변수에 접근하는 것은 불가능하나, 그 역 그러니까 내부 스택 프레임에서 외부 스택 프레임 변수에 접근하는 것은 가능</u>하다.

- 전역 변수는 쓰지 않는 것이 좋음. 
  - 왜? 아마도 mutil thread 환경에서 취약하니까 그러지 않을까?
  - 그래도 써야한다면 읽기 전용의 값으로 값을 공유하는 방법이 있겠음.



##### 메서드

- A 메서드 스택 프레임 , B 메서드 스택 프레임 간에 서로 내부 변수에는 접근이 불가하다.
  - 왜? 포인터 문제. 정확히 접근하고자 하는 내부 변수가 어디있는지 알 수 없음.
  - 알게 만들어주려면, 저장해야하는 변수들이 많아지지 않을까 --> 부담?



##### 멀티스레드, 멀티 프로세스

- 멀티 스레드, 하나의 T 메모리 영역에,  다수의 스택 영역을 가지게 됨. 즉 heap 영역은 공유됨.
- 멀티 프로세스, 다수의 T메모리 영역을 가지게 됨. 각각 메모리 영역끼리는 참조할 수 없음.

- 자바 서블릿은 요청당 **스레드**를 생성함



- 필드 == Field == 속성 == 프로퍼티 == Property
- Funciton == 함수 == 메서드 == Method == 기능 == 행위



## 3부

##### 객체지향 4대특성

- **캡상추다** : 캡슐화, 상속, 추상화, 다형성

- 클래스와 객체를 구분하는 간단한 방법은 나이를 물어보는 것.
- 클래스는 분류에 대한 개념
- 객체는 실체
- 추상 : 여러가지 사물이나 개념에서 **공통되는 특성**, 속성을 추출하여 파악하는 작용
- 클래스 : 객체 = 펭귄 : 뽀로로 = 인간 : 김연아
- 세상에 존재하는 유일무이한 객체를 특성( 속성 + 기능) 에 따라 분류해보니, 객체를 통칭할 수 있는 집합적 개념, 클래스(분류) 가 나오게 된것임.
  - 즉 *클래스 설계를 위해 추상화*가 사용된다.
- 객체 object = 클래스의 인스턴스
- 인간은 객체를 인식하고 나서야, 클래스를 인식하게 된다.
- 프로그래밍적 추상이란..
  - 구체적인 것을 분해해서, 개발자가 관심을 가지고 있는 영역(어플리케이션 영역)에 특성만을 가지고 재조합한 것 == 모델링을 의미한다.
  - 즉 병원 어플리케이션을 만들 때, 사람이라는 모델을 추상화 할때, 롤 티어같은 특성은 필요없을 것.
  - 이러한 추상화는 <u>상속을 통해</u>, <u>인터페이스를 통해</u>, <u>다형성 을 통해</u> 만들어지곤 한다.

- 그래서 모델은 추상화를 통해, 사물을 **단순**하게 표현하는 것

- 자바에서는 `class` 키워드를 통해 객체지향의 추상화를 지원하고 있음.
  - `클래스` `객체-참조-변수` = `new` `클래스()`
  - 왼쪽 클래스는 객체-참조-변수의 자료형 type을 명시
  - 객체-참조-변수는 생성된 인스턴스를 참조할 수 있는 변수(포인터)

- 클래스 멤버, 객체 멤버를 구분하는 키워드는 `static`
- `heap` 영역에 있는 객체가 더 이상 어떠한 변수로부터도 참조되지 않는다면, GC가 작동하여 해당 객체를 메모리에서 제거한다.
  - 이러한 작동은 꽤많은 자원을 소모하는 일이므로 가능하면 최소화해야함.

- 객체는 유일무이하게 존재하는 실체 이기에 속성값을 가질 수 있고, 클래스는 개념이면서 분류체계일 뿐임으로 속성에 값을 가질 수 없음.
  - 그렇지만 만약 같은 유형(클래스) 의 모든 객체가 같은 값을 가지고 있다면, 이 속성 값을 클래스에 저장하는게 좀 더 효율적이지 않을까?
- 클래스 설계
  1. 클래스 멤버 `static`
     - 클래스 멤버 속성
     - 클래스 멤버 메서드
  2. 객체 멤버
     - 객체 멤버 속성
     - 객체 멤버 메서드

- 클래스 멤버들은 `static` 키워드들과 같이 사용되므로 <u>정적 멤버</u>라고도 함
- 객체 멤버들은 객체가, 클래스의 인스턴스 이므로, <u>인스턴스 멤버</u> 라고도 함.
- `main()` 메서드는 정적 메서드 왜? 프로그램이 실행될 때, 메모리에 올라가 있어야 하니까.
- 클래스 속성, 객체 속성은 별도의 초기화를 해주지 않아도, 각 타입별(0.0, false....등)로 초기화가 된다.
  - 그렇지만 지역변수는 별로 초기화를 해줘야함.
  - 왜?
  - 객체 변수는 하나의 객체 안에서 다수의 객체의 메서드가 공유하는 공유변수. 즉 어디에서 초기화를 해줘야할지 역할을 알려주는 것이 애매함.
  - 그렇지만 지역변수는 해당 지역 내에서만 생성, 소멸되므로 반드시 해당 지역에서 초기화해줘야하는 역할을 맡고 있음.



##### 3가지 유형의 변수

1. static
   - 클래스 속성, 정적 변수, 정적 속성
   - 스태틱 영역에서 생성됨.
2. 인스턴스 변수
   - 객체 속성
   - 객체 변수
   - `heap` 영역에 생성됨
3. local 변수
   - 지역 변수
   - `stack` 영역에 생성됨.(stack frame 내부에)



##### 상속 : 재사용 + 확장

- 상속은 상위 클래스 특성을 하위 클래스에 상속(특성 상속), 거기에 하위 클래스만의 **필요한 특성**을 추가(확장) 하여 사용할 수 있다는 뜻.

- 상속관계에서 반드시 만족해야할 문장
  - <u>하위 클래스는 상위 클래스다</u>

- 자바에서 Inheritance 상속이라는 키워드는 존재하지 않음. 대신 extends(확장) 가 존재함

- 객체 잠조명은 객체 답게, 클래스명은 클래스 답게 명명하는 습관을 들이자.
  - 조류 bird = new 조류();
  - 조류의 나이는? 이상함 -> 클래스
  - bird의 나이는? 이상함 -> 클래스

- 상속 관계를 표현하는 영어는 `is a kind of` 관계
  - 펭귄 is a kind of 동물
  - 고래 is a kind of 동물
  - 조류 is a kind of 동물
- 객체 지향 상속은 상위 클래스의 특성을 `재사용 + 확장` 하는 것.
- 객체 지향 상속은 `is a kind of` 관계를 만족해야함

- 다중상속의 **다이아몬드 문제** 때문에 자바, C#에서는 다중 상속을 포기했음.



##### 상속, 인터페이스

- 인터페이스 : 구현 클래스 `is able to` 인터페이스
  - 고래는 헤엄칠 수 있다.
- 무엇을 할 수 있는 이라는 표현 형태가, 클래스와 인터페이스 관계에서는 어울림.
- <u>상위클래스는 물려줄 특성이 풍성</u>할수록 좋고, 
- <u>인터페이스는 구현을 강제할 메서드 갯수가 적을</u> 수록 좋다.

- 두 클래스 간의 상속을 표현하기 위해서는 하위 클래스에서 상위 클래스쪽으로 **화살표**를 그린다.
  - 화살표가 실선일 경우, 인터페이스 관계임.



##### 상속과 T 메모리

- 상속관계 일때 ,하위 클래스의 인스턴스가 생성되면(heap 메모리에 올라가면), 상위 클래스의 인스턴스도 생성된다.



##### 다형성 : 사용편의성

- 오버로딩 Overloading
  - 중복정의, 같은 메서드 이름, 다른 인자 리스트
- 오버라이딩 Overriding
  - 상위클래스의 메서드와 같은 메서드 이름 , 같은 인자 리스트

- ride **올라**타는 것(재정의느낌), load **적재**하는 것(여러개를)

- <u>상위 클래스 타입의 객체 참조 변수</u>를 사용하더라도, **하위 클래스에서 재정의(오버라이딩)** 한 메서드가 호출됨.



##### 캡슐화 : 정보 은닉

- `~ default`
- `# protected`
- `+ public`
- `- private`

- 상속을 받지 않았다면, 객체 멤버는 객체를 생성한 후, 객체 참조 변수를 이용해 접근해야 한다.
- 정적 멤버는 클래스명.정적멤버 형식으로 접근하는 것을 권장한다.
- [ ] chap04 encapsulation01 예제 파일 풀기.



##### 참조 변수의 복사

- 객체 참조 변수를 복사하는 경우?
  - Call By Address
- 그 값 자체로 해석(기본자료형)하느냐, 주소 값(객체)으로 해석 하느냐
- 기본 자료형 변수는 <u>값을 갑 자체</u>로 판단
- 참조 자료형 변수는 <u>값을 주소, 포인터</u> 로 판단
- 기본 자료형 변수를 복사할 때, 참조 자료형을 복사할 때 일어나는 일은 같다.
  - 즉 가지고 있는 값을 복사해서 넘겨준다.



## 4부

##### abstract 

- 추상 메서드 : 선언부는 있는데, 구현부는 없는 메서드
- 추상 클래스는 추상 메서드를 하나라도 갖고 있는 클래스를 의미한다.
  - 추상 클래스는 인스턴스, 객체를 만들수 없는 클래스.
- 추상 클래스를 상속한 하위 클래스는, 추상 메서드 구현이 **강제** 된다.



##### 생성자

- 기본 생성자는 컴파일러가 알아서 만들어 준다.

  ```java
  public class Animal {
  //  public Animal() {} 이부분을 명시적으로 선언해주지 않아도 자동으로 생성됨.
  }
  ```

- 그렇지만 만약 개발자 <u>인자가 있는 생성자를 만든다면</u> 기본 생성자가 자동으로 생성되지 않는다.

  ```java
  public class Animal {
  //  public Animal() {} 이부분이 자동생성되지 않음
    public Animal(String name) { //인자가 있는 생성자를 개발자가 선언
      ....
    }
  }
  ```

  

##### static 블록

- 객체 생성자는 있지만, 클래스 생성자는 존재하지 않음.
- 객체 멤버는 클래스가 `static` 영역에 자리 잡은 후에 객체 생성자를 통해서 `heap` 에 생성됨.
  - 다시 말해 클래스의 static block이 실행되고 있을 때, 해당 클래스의 객체는 아직 heap에 올라가지 않았기에, static 블록에서는 객체 멤버에 접근할 수 없음.
- 메모리는 최대한 늦게 사용을 시작하고, 최대한 빨리 반환하는 것이 정석

```java
public class Driver05 {
  public static void main(String[] args) {
    System.out.println("main method 실행"); //1
    System.out.println(Animal.age); //3
  }
}

class Animal {
  static int age = 0;
  
  static {
    System.out.println("Animal class ready on!"); //2
  }
}
```

- 클래스 정보는 해당 클래스가 콛에서 맨 처음 사용될 때 T 메모리의 스태틱 영역에 로딩 됨.
- 이때 단 한번 해당 클래스의 static 클록이 실행됨.
- 클래스가 제일 처음 사용될 때는?
  1. 클래스의 정적 속성이 사용될때 //위 코드는 1번 상황
  2. 클래스의 정적 메서드를 사용할 때
  3. 클래스의 인스턴스를 만들 때

- <u>{} 블록은 객체 생성자가 실행되기 전에 먼저 실행된다.</u>



##### final

- 이 키워드를 쓸 수 있는 곳은 3군데
- 클래스, 변수, 메서드



1. final class
   - 상속을 허락하지 않겠다.
2. final variable
   - 변경 불가능한 상수를 의미한다.
   - 정적 상수(fianl static int..?) 는 선언 시 혹은 정적 생성자에서 초기화 가능.
   - 객체 상수(final int....) 선언 시 혹은 객체 생성자 혹은 인스턴스 블록 에서 초기화 가능
   - 지역 상수 선언시, 혹은 최소 한번만 초기화 가능.
   - 상수는 한번 초기화 되면 값을 변경할 수 없음.
3. fianl method
   - 오버라이딩 금지. 다시 탈 수 없음. 즉 재정의 불가능함.



##### instaceof 

- 해당 연산자는 생성된 객체가 특정 클래스로의 인스턴스 인지 물어보는 연산자.
- 결과는 `true` or `false` 를 반환한다.



##### package

- 같은 클래스 명을 사용할 지, 이름 충돌을 피하기 위해서 구분되는 기준.



##### interface, implements

- 인터페이스는 추상메서드와 public 정적 상수만을 가질 수 있음.

```java
interface Speakable {
  double PI = 3.141592;
  final double absoluteZeroPoint = -275.15;
  
  void sayYes();
}
```

- 그렇지만 pulic, abstract, static final 속성을 붙이지 않아도 자동으로 자바에서 알아서 해준다.
- 아래 코드와 위는 같은 의미

```java
interface Speakable {
  public static final double PI = 3.141592;
  public static final double absoluteZeroPoint = -275.15;
  
	public abstract void sayYes();
}
```

- 가급적이면 명확하게 정의하자

- 클래스명으로 접근할 수 있는 속성은 정적 속성.



##### this

- 객체가 자기 자신을 지칭 할 때 사용하는 키워드
- 지역 변수와 속성(객체 변수, 정적 변수) 가 이름이 같은 경우에는 **지역 변수** 를 우선 한다.
- 객체 변수와 이름이 같은 지역 변수가 있는 경우, **객체 변수를 사용**하려면 **this**를 접두사로 사용한다.
- 정적 변수와 이름이 같은 지역 변수가 있는 경우, **정적 변수를 사용**하려면 **클래스명**을 접두사로 사용한다.



##### super

- 상위 클래스의 인스턴스를 지칭하는 키워드
- `super` 키워드를 통해 바로 위 상위 인스턴스에는 접근할 수 있지만, `super.super` 형태로 상위 위에 상위 클래스로 접근하는 것은 불가능하다. 이게 허용되면 너무 끝도 없이 진행될 것 같음.



- 객체 메서드가 호출 될 때 stack에 객체명.메서드명 () 이 아닌 클래스명.객체메서드명 () 으로 쌓인다.

  - 왜?
  - 생성되는 객체별로 객체 메서드가 달라지는 것은 아님. 객체 멤버 메서드에서 사용하는 객체 멤버 속성 값만 다를 뿐. 
  - 즉 메모리 낭비를 막기 위해서 heap에는 해당 클래스로 하나만 생성됨.
  - 그리고 test 메서드는 스태틱 영역에 **단 하나만** 보유하게됨. (힙에 계속해서 생성안됨.)

  ```java
  class 펭귄 {
    static void test(펭귄 this){
      System.out.println("Test");
    }
  }
  
  public class Drvier {
    public static void main(String[] args) {
      펭귄 뽀로로 = new 펭귄 ();
      펭귄.test(뽀로로);
    }
  }
  ```

  - 이와 같은 형태로 JVM에서 읽어들이게 됨.
  - main stack 영역에는 args, 뽀로로  --> heap (펭귄) ,test 메서드 없음.
  - 펭귄.test(뽀로로) stack frame
  - static 영역에는 펭귄(test(this : 펭귄))