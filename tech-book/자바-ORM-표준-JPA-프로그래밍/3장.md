# Entity Manger

- 엔티티들을 관리하는 공장
- 생성하는 데 굉장히 많은 자원이 소모된다.
  - 그래서 미리 생성한 Entity Manger Factory에서 생성하도록 한다. -- > 자원소모가 덜하다



# 영속성 컨텍스트

- Persistence Context
- 엔티티를 영구 저장하는 환경을 의미한다.
- `em.persist(member)` 는 엔티티 매니저를 이용해서 회원 엔티티를 **영속성 컨텍스트에 저장**하는 것
- 엔티티 매니저를 생성할 때 하나 만들어진다.



## 엔티티 생명주기

### 비영속

- 영속성 컨텍스트와 전혀 관계 없는 상태
- 순수 객체 상태

### 영속

- 영속성 컨텍스트에 저장된 상태
- 엔티티 매니저를 통해서 해당 엔티티를 영속성 컨텍스트에 저장한 것
- 즉 해당 엔티는 영속성 컨텍스트에 의해 관리되고 있다는 의미이다.

### 준영속

- 영속성 컨텍스트에 저장되어 있다가 분리된 상태
- 영속성 컨텍스트가 해당 엔티티를 관리하고 있지 않는 상태를 의미한다.

### 삭제

- 삭제된 상태
- 영속성 컨텍스트와 데이터베이스에서 해당 엔티티가 삭제된 상태를 의미한다.



## 영속성 컨텍스트 특징

- 영속상태에서는 반드시 식별자(id)가 있어야한다. 
  - 없으면 예외발생
- JPA는 보통 트랜잭션을 커밋한 순간에, 영속성 컨텍스트에 **새로 저장된 엔티티** 를 DB에 반영함. 이를 `Flush` 라 한다.
- 장점도 많다
  - 1차 캐시, 동일성 보장, 트랜잭션을 지원하는 쓰기 지연, 변경 감지, 지연 로딩...
  - 장점일까?



### 엔티티 조회

- 1차 캐시 : 영속성 컨텍스트는 내부 캐시를 가지고 있음. 
  - 영속 상태의 엔티티는 모두 1차 캐시에 저장된다.
  - 일단 영속을 실행하면 DB에 바로 반영되지 않고, 1차 캐시에 저장된다.
- 조회를 하면 일단 1차 캐시에서 찾고, 없으면 DB를 조회한다.
  - 그리고 1차 캐시에 저장한 후에, 엔티티를 반환한다
- 1차 캐시는 영속성 컨텍스트와 DB의 중간자 다리 역할인듯.



### 영속 엔티티의 동일성 보장

```java
Member a = em.find(Member.class, "member1");
Member b = em.find(Member.class, "member1");

//a==b?? 참!
```

- 왜? 1차 캐시에 있는 엔티티 인스턴스를 반환하므로, 결국 같은 주소를 반환하고 있다고 생각할 수 있음.



### 엔티티 등록

- 엔티티 매니저는 **트랜잭션을 커밋하기 직전** 까지 데이터베이스에 엔티티를 저장하지 않고, 내부 쿼리 저장소에 INSERT QUERY를 모아둔다
  - 그러다가 트랜잭션이 커밋이 되면 모아둔 쿼리를 한꺼번에 데이터 베이스에 보낸다
  - 이러한 것을 **쓰기 지연** 이라 부른다

- 성능 최적화에 도움을 준다.



### 엔티티 수정

- 변경감시 Dirty Checking 기능을 지원해줌
- JPA는 엔티티를 영속성 컨텍스트에 보관할때, 최초 상태를 복사해서 저장해둔다 --> **스냅샷**
- Flush 시점에 스냅샷과 엔티티를 비교해서, 변경된 엔티티를 찾아서
- 변경된 엔티티가 있으면 수정쿼리를 생성하고 내부 SQL 저장소에 보낸다.
- 그리고 내부 SQL 저장소는 모아둔 쿼리를 데이터베이스에 보내고
- 데이터베이스 트랜잭션을 커밋한다.
- 변경 감지 기능은 영속성 컨텍스트에서 관리하고 있는 엔티티에만 해당한다.
  - 비영속, 준영속 상태인 엔티티에는 해당하지 않는다.
- 컬럼이 30개 이상이면, 정적 수정 쿼리 보다 , @DynamicUpdate를 사용한 동적쿼리 빠르다고 함.



### 엔티티 삭제

- 삭제가 호출된 순간 해당 엔티티는 영속성 컨텍스트에서 제거되고

- 삭제 쿼리가 지연 SQL 저장소에 등록되고
- 이후 트랜잭션을 커밋하면, Flush가 호출되어서 데이터베이스에 쿼리 저장소에 있던 쿼리들이 전달된다.



## Flush

- 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영하는 것을 의미한다.
- 실행 단계
  1. 변경 감지 Dirty Checking이 동작 --> 영속성 컨텍스트에서 관리하는 모든 엔티티들의 **스냅샷과 비교해서 수정된 엔티티를 찾는다**.
  2. 수정된 엔티티를 기반으로 수정 쿼리를 작성하고, **쓰기 지연 SQL 저장소**에 저장한다.
  3. SQL 저장소에 있는 쿼리를 모두 데이터 베이스에 전송한다.
- 사용하는 방법
  1. em.flush() 호출
     - 추천하지 않는 방법, 
  2. 트랜잭션 커밋시 자동으로 호출됨.
     - 단순히 트랜잭션만 커밋한다고 변경데이터가 데이터베이스에 반영되지 않음.
     - 변경내용 SQL을 데이터베이스에 전송해야한다. 이걸 Flush가 해준다.
  3. JPQL 쿼리 실행 시 플러시가 자동으로 호출됨.
- 플러시는 영속성 컨텍스트에 보관된 엔티티를 지우는 것이 아님.
  - 영속성 컨텍스트에서 관리하는 엔티티중 변경내용이 있는 엔티티들을 찾아서 데이터 베이스에 반영하는 것을 의미한다.



### 플러시 모드 옵션

- FlushModeType.AUTO : 커밋이나 쿼리 실행할 때 플러시 (기본값)
- FlushModeType.COMMIT : 커밋할 때만 플러시





## 준영속

- 준영속 상태는 영속성 컨텍스트에서 엔티티가 detached 된 것을 의미.
- 즉 영속성 컨텍스트에서 제공하는 기능들을 사용할 수 없음.
- `em.detach()` 하는 순간 1차 캐시 부터, 쓰기 지연 SQL 저장소까지 해당 엔티티에 해당하는 모든 정보들이 제거 된다.



### clear()

- 영속성 컨텍스트를 초기화 하여, 해당 영속성 컨텍스트에서 관리하는 모든 엔티티들을 준영속 상태로 만드는 메서드



### close()

- 영속성 컨텍스를 종료하는 메서드
- 종료하면 관리상태이던 엔티티들이 **모두 준영속 상태**가 된다



### 준영속 상태의 특징

- 식별자 값을 가지고 있긴 함
- 거의 비영속 상태에 가깝다.
  - 즉 1차 캐시, 쓰기 지연, 변경감지, 지연 로딩등의 기능을 사용할 수 없음.
- 지연 로딩을 할 수가 없음.
  - 지연로딩은 실체 객체 대신 프록시 객체를 로딩해두고, 해당 객체를 실제 사용할 때 영속성 컨텍스트를 통해서 데이터를 불러오는 방법을 의미한다.



### merge()

- 준영속 상태의 엔티티를 다시 영속 상태로 변경할 때 사용하는메서드





# 정리

- 영속성 컨텍스트는 Java application  과 데이터베이스 사이에서 객체를 보관하는 가상의 데이터 베이스 역할임.
- 영속성 컨텍스트로 인하여, 1차 캐시, 동일성 보장, 트랜잭션을 지원하는 쓰기 지연, 변경 감지, 지연 로딩등의 기능들이 가능하다.
- 플러시는 트랜잭션이 커밋될 때 시행된다.

