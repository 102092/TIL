#  자료구조와 함께 배우는 알고리즘 입문

- 참고

  [자료구조와..](http://www.yes24.com/Product/Goods/57798536)

- Goal
  1. `java`를 기반으로 자료구조와 알고리즘 기본사항을 배운다.
  2. 꼭 알아둬야할만한 사항은 따로 체크한다.
  3. 연습문제는 혼자힘으로 풀어본다.

-----



## 1. 반복

### 1.1 for

```java
for(int i =1; i <=n; i++)
    sum += i; //{}없이 사용가능
for(int i =1; i <=n; i++) sum += i; //가로형식으로 사용가능
```



### 1.2 do~while

- 일단 `do` 문을 한번 실행한다음에 계속 반복할 것인지 `while` 문을 통해 판멸함
- 사후 판단 반복

- **논리 연산자**

  ![](https://miro.medium.com/max/700/0*YH506ZYL1rLNKQiK.)





## 2. 배열

- `int[] a;` a는 자료형이 int인 배열을 선언한것
  - `int a[]` 이렇게해도 되지만. 앞에것을 먼저 쓰자
  - [] 안에는 배열의 크기가 들어간다.
  - 배열의 index는 *0부터* 시작
- 배열.length // 배열의 구성요소의 수
- 배열.clone() // 배열의 복제 쉽게



#### 2.1 배열의 최대값 구하기

```java
max = a[0];
for(int i=1; i < n; i++)
    if(a[i] >max) max = a[i];
//요소의 크기가 n개면 인덱스가 1부터 시작하므로 n-1까지 비교하면 되겠군
```

- 시간복잡도 O(n-1) 



#### 2.2 배열  역순으로 정렬

- 요소의 개수/2 ,나머지는 버림. 왜? 홀수인 경우에는 가운데 요소는 교환할 필요가 없네?
- `temp` 을 사용 즉 `swap` 한다

```java
static void swap(int[] a, int idx1, int idx2){
    int t = a[idx1];
    a[idx1] = a[idx2];
    a[idx2] = t; // a[idx1] 과 a[idx2]를 교환
}
static void reverse(int[] a){
    for(int i =0; i<a.length /2; i++)
        swap(a,i,a.length-i-1);
}
```



#### 2.3 두 배열 비교

1. 두 배열의 길이를 비교

2. `for`  문을 이용하여 처음부터 스캔하면서 서로 비교함.

   중간에 다른 요소를 발견하면 반환문을 실행하여 `false` 를 반환

3. 마지막까지 같으면, `true` 반환

```java
static boolean equals(int[] a, int[] b){
    if(a.length != b.length)
        return false;
    for(int i =0; i <a.length; i++)
        if(a[i] !=b[i])
            return false;
    return true;
}
```



#### 2.4 기수 변환

1. 10진수 정수를 n진수 정수로 변환? 정수를 n으로 나눈 나머지를 구하는 동시에 그 몫에 대한 나눗셈을 반복해야 할 수 있음. 

   언제까지? 몫이 0이 될때 까지.



## 3. 검색

### 3.1 검색알고리즘

- 배열검색

- 선형 리스트 검색

  무작위 데이터 중에서..

- 이진 트리 검색

  일정한 규칙으로 늘어놓은 데이터 모임에서



### 3.2 선형검색

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=http%3A%2F%2Fcfile24.uf.tistory.com%2Fimage%2F21551044519E0D53397638)

- 인덱스를 하나씩 증가시켜 가며, 배열의 첫번째 부터 끝까지, 하나씩 검색하는 방법
- 보통 반복문`for,while` 을 사용함.
- 무한 루프 구현법

```java
while(true){
    
}
for( ; ; ){
    
}
```



- **시간복잡도 O(n)**

  O(1) ? 한번만 실행되는 경우

  O(n) 은 n에 비례되어 실행되는 회수이기 때문



#### 보초법

- 검색하기 전에 검색하고자 하는 키 값을 배열의 맨끝 요소에 배치하는 것.

- 왜?

  그러면 종료조건 회수를 줄일 수 있음.

  즉 보통 종료조건은 1. 검색할 값을 발견하지 못하고, 지나간 경우, 2. 검색할 값과 같은 요소를 발견한 경우 2가지로 나뉘는데, 

  2번만 체크하게 되니까.

```java
static int seqSearchSen(int[] a, int n, int key){
    int i = 0;
    a[n] = key; //배열 맨 마지막에 보초를 추가함.
    
    while(true){
        if(a[i] == key) break;
        i++
    }
    return i == n ? -1 : i;// index값이 n과 같으면 보초가 발동하는 거니까 -1
}
```



#### 이진검색

- 전제조건 ! 데이터가 키 값으로 *정렬* 되어 있음
- 이진 검색은 선형검색보다 조금 빠르다.

![](https://i.imgur.com/hhiR6QU.png)

- 반 잘라서 찾는 방법. 그래서 **정렬** 되었음을 가정하구나



```java
class BinSearch{
    static int binSearch(int[] a, int n, int key){
        int pl = 0;
        int pr = n -1;//배열의 마지막
        
        do{
            int pc = (pl+pr) / 2; //중앙 인덱스값
            if(a[pc] == key)
                return pc;
            else if(a[pc] < key) // 찾고자하는 값이 중앙값 보다 크다면, 중앙값 뒤를 살펴봐야겠지?
                pl = pc + 1;
            else
                pr = pc - 1;
        } while(pl <= pr);
    }
}
```



- **시간복잡도 O(log n)**



## 4. 스택과 큐

### 4.1 스택

- 데이터를 일시적으로 저장하기 위해 사용하는 자료구조
- *Last In Frist Out* **LIFO**
- 데이터를 넣는다? `push` 데이터를 꺼낸다? `pop`

![](https://upload.wikimedia.org/wikipedia/commons/thumb/2/29/Data_stack.svg/300px-Data_stack.svg.png)

- `push`,`pop`을 하는 위치를 TOP라 하고, 스택의 가장 아랫부분은 Bottom이라 함.
  - 가장 아랫부분부터 차곡차곡 쌓이겠군
- 넣고 빼는 곳이 한군데!

- **자바** 프로그램은 메서드 호출과 실행을 *스택*구조로 실행함.



#### 기본 구조

```java
public int max; //stack 용량
public int ptr; //포인터
private int[] stk; //본체

public class Empty extends RuntimeException{
    public Empty(){} //스택이 비어있을 때 실행됨
}

public class Overflow extends RuntimeException{
    public OverFlow(){} //스택이 넘쳐흐를 때 실행됨.
}


public InStact(int capacity){//생성자
    ptr =0; //처음위치는 0 가득차면 max와 같겠군
    max = capacity; //용량은 매개변수로 받고
    try{
    stk = new int[max]; //빈배열
    }catch(OutOfMemoryError e{ //생성할 수 없으면
        max = 0;        
    }
}
```



#### Push

- 데이터 추가
- 가장 아래서 부터 쌓임. 
- 데이터가 먼저 쌓이고 포인터가 이동됨.

```java
public int push(int x) throws Overflow {
    if(ptr >= max)
        throw new Overflow(); //넘쳐흐를정도가 되면 오류를 던지고
    return stk[ptr++] = x; // ptr값에 x가 도입되고, ptr값이 ++됨(포인터가 이동)
}   
```



#### Pop

- 데이터 삭제
- 가장 위부터 삭제되고,
- 데이터가 먼저삭제되고 포인터(ptr)이 이동함

```java
public int pop() throws Empty {
    if(ptr <= 0) //스택이 비어있으면
        throw new Empty();
    return stk[--ptr]; //먼저--한 ptr값이 없어짐
}
```



#### Peek

- 엿보기, 꼭대기에 뭐가 있을까?

```java
public int peek() throws Empty{
    if(ptr <=0)
        throw new Empty(); //아무것도 없으면 엿볼 수 없음
    return stk[ptr-1]; //포인터ptr은 항상 마지막 데이터 다음에 있으니까
}
```



#### IndexOf

- 검색메서드
- 선형검색 가장 나중에 삽입된 데이터 부터 시작해서 차근차근 찾는 방법
- 검색에 성공하면 찾아낸 요소의 **인덱스**를 반환, 아니면  **-1** 반환

```java
public int indexOf(int x){
    for(int i= ptr-1; i>=0; i--;){
        if(stk[i]==x)
            return i;
        return -1;
    }
}
```



#### Etc

- `clear, capacity, size, isEmpty, IsFull`등의 메서드가 있다

```java
public void clear(){
    ptr = 0;
}

public int capacity(){
    return max;
}
public int size(){
    return ptr;
}
public boolean IsEmpty(){
    return ptr <=0;
}

public boolean isFull(){
    return ptr >=max;
}
```



### 4.2 큐

- 데이터를 일시적으로 쌓아두기 위한 자료 구조
- *First in First out*

- 보통 매장에서 줄 서는 라인을 생각하면 될듯.
- 데이터를 넣는다? `enqueue`  데이터를 꺼낸다? `dequeue` 
- 데이터를 꺼내는 쪽 front, 넣는 쪽 rear(리어)

![](https://t1.daumcdn.net/cfile/tistory/21020B4B57410F5A31)

- 넣고 들어가는 문이 따로 있네

- 배열을 이용하여 만드는데, dequeue를 하면, 데이터를 한칸씩 옯겨야 겠네 => <u>복잡도 O(n)</u>

  배열 요소를 앞쪽으로 옮기 않는 큐는? **링 버퍼(ring buffer)**

![](https://vitamindragon.github.io/assets/images/queue.jpg)

- 프런트 : 맨 처음 요소의 인덱스

- 리어 : 맨 끝 요소의 하나 뒤 인덱스(즉 다음 요소를 인큐할 위치를 미리 지정해 놓는 방식

  이렇게 연결되어있으면 <u>복잡도? O(1)</u>

#### 기본구조

```JAVA
public class intQueue{
    private int max; //큐 총량;
    private int front; // 맨 처음 요소의 인덱스
    private int rear; //맨 끝 요소에서 하나를 더한 인덱스(다음 요소가 들어갈)
    private int num; //현재 데이터 수
    private int[] que; //큐 본체
    
    public class Empty extends RuntimeException{
    public Empty(){} 
}

    public class Overflow extends RuntimeException{
        public OverFlow(){} 
    }
    public intQueue(int capacity){
        num = front = rear = 0;
        max = capacity;
        try{
            que = new int[max]; //max만큼 배열을 만듬 = 큐 본체
        }catch(OutOfMemoryError e){
            max = 0;
        }
    }
    
}
```



#### Enqueue

```java
public int enque(int x) throws Overflow{
    if(num >= max)
        throw new Overflow;
    que[rear++] =x; //x를 enqueue하고 rear포인트 이동시키고
    num++
    if(rear ==max) //rear값이 max값과 같아지지 않도록 한다. 없는 공간을 rear가 가르키지 않도록. 배열 인덱스는 0부터 시작이니까
        rear =0;
    return x;
}
```



#### Deque

```java
public int deque() throws Empty{
    if(num <=0 )
        throw new Empty;
    int x = que[front++]; //현재 front에 있는 값을 꺼내서 x에 저장한 다음, front값을 증가시킴
    num--; //그리고 총 갯수를 감소시킨다음에
    if(front == max)
        front =0; //맨 처음 요소의 인덱스 값이 큐의 총량 값과 같으면 현재 큐는 빈것
    return x;
}
```



#### Peek

```java
public int peek() throws Empty{
    if(num<=0)
        throw new Empty;
    return que[front]; //
}
```



#### IndexOf

```java
public int indexOf(int x){
    for(int i =0; i<num; i++){
        int idx = (i+front) % max;
        if(que[idx] ==x)
            return idx;
    }
    return -1;
}
```



#### Etc

```java
public void clear(){
    num = front = rear =0;
}

public int capacity(){
    return max;
}

public int size() { //큐에 쌓여있는 데이터 숫자
    return num;
}

public boolean isEmpty(){
    return num <=0;
}

public boolean isFull(){
    return num >=max;
}

//큐안에 쌓여있는 데이터가 프런트(앞) 부터 리어(뒤)순으로 출력
public void dump(){
    if(num<=0)
        System.out.println("큐가 비어있습니당");
    else{
        for(int i =0; i < num; i++)
            System.out.print(que[(i+front)%max] +" ");
        System.out.println();
    }
}
```

