#  자료구조와 함께 배우는 알고리즘 입문

- 참고

  [자료구조와..](http://www.yes24.com/Product/Goods/57798536)

- Goal
  1. `java`를 기반으로 자료구조와 알고리즘 기본사항을 배운다.
  2. 꼭 알아둬야할만한 사항은 따로 체크한다.
  3. 연습문제는 혼자힘으로 풀어본다.

-----



## 4. 스택과 큐

### 4.1 스택

- 데이터를 일시적으로 저장하기 위해 사용하는 자료구조
- *Last In Frist Out* **LIFO**
- 데이터를 넣는다? `push` 데이터를 꺼낸다? `pop`

![](https://upload.wikimedia.org/wikipedia/commons/thumb/2/29/Data_stack.svg/300px-Data_stack.svg.png)

- `push`,`pop`을 하는 위치를 TOP라 하고, 스택의 가장 아랫부분은 Bottom이라 함.
  - 가장 아랫부분부터 차곡차곡 쌓이겠군
- 넣고 빼는 곳이 한군데!

- **자바** 프로그램은 메서드 호출과 실행을 *스택*구조로 실행함.



#### 기본 구조

```java
public int max; //stack 용량
public int ptr; //포인터
private int[] stk; //본체

public class Empty extends RuntimeException{
    public Empty(){} //스택이 비어있을 때 실행됨
}

public class Overflow extends RuntimeException{
    public OverFlow(){} //스택이 넘쳐흐를 때 실행됨.
}


public InStact(int capacity){//생성자
    ptr =0; //처음위치는 0 가득차면 max와 같겠군
    max = capacity; //용량은 매개변수로 받고
    try{
    stk = new int[max]; //빈배열
    }catch(OutOfMemoryError e{ //생성할 수 없으면
        max = 0;        
    }
}
```



#### Push

- 데이터 추가
- 가장 아래서 부터 쌓임. 
- 데이터가 먼저 쌓이고 포인터가 이동됨.

```java
public int push(int x) throws Overflow {
    if(ptr >= max)
        throw new Overflow(); //넘쳐흐를정도가 되면 오류를 던지고
    return stk[ptr++] = x; // ptr값에 x가 도입되고, ptr값이 ++됨(포인터가 이동)
}   
```



#### Pop

- 데이터 삭제
- 가장 위부터 삭제되고,
- 데이터가 먼저삭제되고 포인터(ptr)이 이동함

```java
public int pop() throws Empty {
    if(ptr <= 0) //스택이 비어있으면
        throw new Empty();
    return stk[--ptr]; //먼저--한 ptr값이 없어짐
}
```



#### Peek

- 엿보기, 꼭대기에 뭐가 있을까?

```java
public int peek() throws Empty{
    if(ptr <=0)
        throw new Empty(); //아무것도 없으면 엿볼 수 없음
    return stk[ptr-1]; //포인터ptr은 항상 마지막 데이터 다음에 있으니까
}
```



#### IndexOf

- 검색메서드
- 선형검색 가장 나중에 삽입된 데이터 부터 시작해서 차근차근 찾는 방법
- 검색에 성공하면 찾아낸 요소의 **인덱스**를 반환, 아니면  **-1** 반환

```java
public int indexOf(int x){
    for(int i= ptr-1; i>=0; i--;){
        if(stk[i]==x)
            return i;
        return -1;
    }
}
```



#### Etc

- `clear, capacity, size, isEmpty, IsFull`등의 메서드가 있다

```java
public void clear(){
    ptr = 0;
}

public int capacity(){
    return max;
}
public int size(){
    return ptr;
}
public boolean IsEmpty(){
    return ptr <=0;
}

public boolean isFull(){
    return ptr >=max;
}
```



### 4.2 큐

- 데이터를 일시적으로 쌓아두기 위한 자료 구조
- *First in First out*

- 보통 매장에서 줄 서는 라인을 생각하면 될듯.
- 데이터를 넣는다? `enqueue`  데이터를 꺼낸다? `dequeue` 
- 데이터를 꺼내는 쪽 front, 넣는 쪽 rear(리어)

![](https://t1.daumcdn.net/cfile/tistory/21020B4B57410F5A31)

- 넣고 들어가는 문이 따로 있네

- 배열을 이용하여 만드는데, dequeue를 하면, 데이터를 한칸씩 옯겨야 겠네 => <u>복잡도 O(n)</u>

  배열 요소를 앞쪽으로 옮기 않는 큐는? **링 버퍼(ring buffer)**

![](https://vitamindragon.github.io/assets/images/queue.jpg)

- 프런트 : 맨 처음 요소의 인덱스

- 리어 : 맨 끝 요소의 하나 뒤 인덱스(즉 다음 요소를 인큐할 위치를 미리 지정해 놓는 방식

  이렇게 연결되어있으면 <u>복잡도? O(1)</u>

#### 기본구조

```JAVA
public class intQueue{
    private int max; //큐 총량;
    private int front; // 맨 처음 요소의 인덱스
    private int rear; //맨 끝 요소에서 하나를 더한 인덱스(다음 요소가 들어갈)
    private int num; //현재 데이터 수
    private int[] que; //큐 본체
    
    public class Empty extends RuntimeException{
    public Empty(){} 
}

    public class Overflow extends RuntimeException{
        public OverFlow(){} 
    }
    public intQueue(int capacity){
        num = front = rear = 0;
        max = capacity;
        try{
            que = new int[max]; //max만큼 배열을 만듬 = 큐 본체
        }catch(OutOfMemoryError e){
            max = 0;
        }
    }
    
}
```



#### Enqueue

```java
public int enque(int x) throws Overflow{
    if(num >= max)
        throw new Overflow;
    que[rear++] =x; //x를 enqueue하고 rear포인트 이동시키고
    num++
    if(rear ==max) //rear값이 max값과 같아지지 않도록 한다. 없는 공간을 rear가 가르키지 않도록. 배열 인덱스는 0부터 시작이니까
        rear =0;
    return x;
}
```



#### Deque

```java
public int deque() throws Empty{
    if(num <=0 )
        throw new Empty;
    int x = que[front++]; //현재 front에 있는 값을 꺼내서 x에 저장한 다음, front값을 증가시킴
    num--; //그리고 총 갯수를 감소시킨다음에
    if(front == max)
        front =0; //맨 처음 요소의 인덱스 값이 큐의 총량 값과 같으면 현재 큐는 빈것
    return x;
}
```



#### Peek

```java
public int peek() throws Empty{
    if(num<=0)
        throw new Empty;
    return que[front]; //
}
```



#### IndexOf

```java
public int indexOf(int x){
    for(int i =0; i<num; i++){
        int idx = (i+front) % max;
        if(que[idx] ==x)
            return idx;
    }
    return -1;
}
```



#### Etc

```java
public void clear(){
    num = front = rear =0;
}

public int capacity(){
    return max;
}

public int size() { //큐에 쌓여있는 데이터 숫자
    return num;
}

public boolean isEmpty(){
    return num <=0;
}

public boolean isFull(){
    return num >=max;
}

//큐안에 쌓여있는 데이터가 프런트(앞) 부터 리어(뒤)순으로 출력
public void dump(){
    if(num<=0)
        System.out.println("큐가 비어있습니당");
    else{
        for(int i =0; i < num; i++)
            System.out.print(que[(i+front)%max] +" ");
        System.out.println();
    }
}
```

