## 참고

- [코딩인터뷰완전분석](http://www.yes24.com/Product/Goods/44305533)

- [심볼 참고](https://csrgxtu.github.io/2015/03/20/Writing-Mathematic-Fomulars-in-Markdown/)

## 목표

- 알고리즘, 자료구조 기본 복습
- 직접 코드 써보기



## big-O

- 알고리즘의 효율성을 나타내는 지표, 언어

  

---

[참고사항] - -big-O, big-theta, big-omega

- big-O :  시간의 상한. 알고리즘 수행 시간의 **상한**
- big-omega : $\Omega$ 오메가? 등가, 하한을 의미.
  - 배열의 모든 값을 출력하는 알고리즘은 $\omega(N)$ , $\omega(logN)$ , $\omega(1)$ 로 표현 가능하다. 즉 $\omega$ 보다 수행시간이 빠를 수 없다.
- big-theta : $\theta$ , O 와 $\Omega$ 둘 다 의미함.
  - 어떤 알고리즘 수행시간이 O(N) 이면서 $\Omega(N)$ 이라면, 최대 N 이면서 최소 N걸린다면 이 알고리즘의 수행 시간을 $\theta(N)$ 이라 표현할 수 있음.

---

- 알고리즘은 최선, 최악, 평균적인 경우의 수행시간을 보유하고 있다.
  - <u>최선의 경우는 별로 쓸모 없음.</u> 

- **big-O 는 최대 걸리는 시간**, big-$\Omega$ 는 최소 걸리는 시간, big-$\theta$ 는 딱 맞는 수행 시간.



### 공간복잡도

- 메모리의 최선을 찾기 위한 개념.
  - 크기가 n인 배열을 만들고자 하면? O(n) 의 공간이 필요하다고 이야기 할 수 있음.
  - n x n 이차원 배열을 만들고자 하면? O($n^2%$) 의 공간이 필요.



### 상수항은 무시하자

- 왜? 특수한 입력에 한해서 O(N) 의 수행시간을 갖는 알고리즘이 O(1) 보다 빠르게 동작할 수 있으니까.
- O(2N) 이어도 O(N)으로 표기하자.



### 수식에서 지배적이지 않은 항은 무시하자

- O($n^2$ +$n$) 은 O($n^2$)
- O($N+ logN$) 은 O($N$)

- O($5*2^N+1000N^{100}$) 은 O($2^N$)

![](https://hoseockchoi.files.wordpress.com/2019/04/unnamed-2.png)



### 수행시간 덧셈, 곱셈

- 수행시간을 언제 더하고, 곱할 수있을까?
  - 알고리즘이 A를 모두 끝내고 B를 한다? :: 더함
  - 알고리즘이 A를 수행 할때마다 B를 하면? :: 곱합

- O($A+B$)

```java
for(int a : arrA){
  print(a);
}
for(int b: arrB){
  print(b);
}
```



- O($A*B$)

```java
for(int a : arrA){
  for(int b : arrB){
    print(a+","+b)
  }
}
```



### 상환시간

- `ArrayList` 
  - 동적 가변 크기 배열, 배열이지만 동시에 크기를 자유롭게 조정할 수 있음 어떻게?
  - 용량이 꽉찼을 때, 기존 크기보다 **두 배** 더 큰 배열을 자동으로 만들고, 이전 원소들을 새 배열로 모두 **복사** 함.
  - 이 때 <u>삽입 연산 시간</u>은?
    - O($N$) 아닐까? 
      - 이 경우는 배열이 가득 차있을 경우.
      - 배열이 가득차있지 않을 경우에는 O($1$) 만큼의 시간이 걸림.
    - 이 두가지를 포함하는 전체 수행 시간을 고려해야 함. 이를 위해 상환시간이라는 개념을 이용.
- 상환시간?
  - 최악의 경우는 가끔 발생, 그렇지만 한 번 발생하면 그 텀이 길지. 그러므로 최악의 경우 걸리는 수행 시간을 분할해서 상환한다는 개념.

- X개 원소를 삽입했을 때 필요한 시간은 O($2X$)이고, 이를 분할 상환해보면 삽입 한번에 필요한 시간은 O($1$) 임



### logN 수행시간

- 어떤 문제에서 원소의 개수가 **절반** 씩 줄어든다면 수행시간은 $log(N)$ 일 가능성이 높음.
- **이진 탐색 트리**가 이에 해당
- $log$ 의 밑은 상수항으로 취급되기 때문에 무시해도 됨



### 재귀적 수행 시간

```c
int f(int n){
  if(n <=1){
    return 1;
  }
  return f(n-1) + f(n-1);
}
```

- 위의 코드는 재귀적 구성을 가지고 있음.
- 수행 시간은?
  - 예시를 넣어서 얼마나 수행되는지 보면 됨.
  - f(4) | f(3) *2 | f(2) * 4 | f(1) * 8
  - 1 | 2 | 4 | 8 ... $2^{N+1}-1$
  - 따라서 수행시간은 O($2^N$)
  - 공간복잡도는 O($N$)

- 지수에서의 밑은 수행시간 측정시 무시하면 **안됨.**



> 참고

- [https://hoseockchoi.wordpress.com/2019/04/05/time-complexity-%EC%99%80-space-complexity-%EC%97%90-%EB%8C%80%ED%95%9C-%EC%9D%B4%ED%95%B4-%EA%B7%B8%EB%A6%AC%EA%B3%A0-code-review-%EA%B4%80%EC%A0%90%EC%97%90%EC%84%9C-%EB%8B%A4%EC%8B%9C-%EB%B3%B4/](https://hoseockchoi.wordpress.com/2019/04/05/time-complexity-와-space-complexity-에-대한-이해-그리고-code-review-관점에서-다시-보/)