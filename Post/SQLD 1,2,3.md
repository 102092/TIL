## SQLD 1,2,3

### 1

- 데이터 모델링 유의점은?
  
  - 중복 : 같은 정보를 저장하지 않도록
  - 비유연성 : 데이터 정의, 사용프로세스를 분리함으로써 작은 변화가 데이터베이스에 중대한 변화를 일으킬 수 있는 가능성을 줄인다
  - 비일관성 : 데이터간 상호연관성을 명확하게 정의한다.
  
- 3단계 구조
  1. 외부 스키마 : 사용자 응용프로그래머 관점에서,
  2. 개념 스키마 : 모든 사용자 관점을 통합한 조직 전체 관점의 통합적 표현
  3. 내부 스키마 : 시스템 개발자 관점

- ERD

  1. 엔티티 도출
  2. 엔티티 배치
  3. 관계 설정
  4. 관계 기술

  - 피터첸



- 엔티티

  - 반드시 해당 업무에서 필요하고 ,관리하고자 하는 정보여어
  - 유일한 식별자에 의해 식별이 가능
  - 2개 이상 인스턴스 집합
  - 반드시 속성이 있어야함
  - 최소 1개 이상 다른 엔티티와의 관계가 설정되어야 함

- 엔티티 종류

  1. 기본(키)
  2. 중심(메인)
  3. 행위
  4. 개념

  - 엔티티이름을 명명할 때는 가능한 약어를 쓰지 않는다.

- 속성

  - 더 이상 분리되지 않는 최소의 데이터 단위
  - 한 개의 속성은 한 개의 속성값을 가짐
  - 하나의 엔티티는 2개 이상 속성을 가짐

  1. 기본
  2. 파생 : 데이터를 조회할 때 빠른 성능을 할 수 있도록 하기 위해 원래 속성값을 계산하여 저장할 수 있도록 만든 속성
  3. 설계
  4. PK



- 도메인
  
- 각 속성이 가질 수 있는 범위를 일컫는 말
  
- 데이터 모델링에서는 존재적 관계, 행위에 의한 관계를 구분하는 표기법 없음

  UML에서는 연관관계, 의존관계에 대한 다른 표기법을 가지고 표현하게 되어있음.



- 관계
  - 존재적, 행위에 의한으로 나뉨
  - 표기법은 관계명, 관계차수, 선택성 3가지 개념을 사용
  - 동사는 관계를 서술하는 업무기술서의 가장 중요한 사항
- 주식별자
  - 지정되면 반드시 값이 있어야 하고,
  - 주식별자에 의해 모든 인스턴스들이 명확하게 구분되어야함
  - 유일성, 유일하게 구분할 수 있어야하고
  - 최소성, 구성하는 속성의 수가 최소이어야 하고,
  - 불변성, 변하면 안되고
  - 존재성 , null안되고

- 식별자 종류
  1. 대표성 ? 주식별자, 보조 식별자
  2. 스스로 생성? 내부식별자, 외부식별자
  3. 단일 속성으로 식별이 되는가? 단일 식별자, 복합식별자
  4. 원래 있었던 것을 대체? 본질 식별자, 인조 식별자
     - 사번은 본질식별자
     - 인조식별자는 시스템적으로 일부러 만들어서 부여하는
- 성능데이터베이스 모델은, 성능향상을 목적으로 설계된것

- 반정규화

  1. 정규화를 시행하고
  2. 데이터베이스 용량산정을 수행하고
  3. 트랜잭션 유형을 파악하고
  4. 용량, 트랜잭션 유형에 따라 반 정규화를 실행하고
  5. 이력모델 조정, pk/fk 조정, 슈퍼/서브 타입 조정하고
  6. 성능관점에서 데이터 모델을 검증함

  - 데이터 무결성이 깨질 수 있는 위험을 무릎쓰고, 데이터를 중복하여 반정규화를 실행함
  - 왜? 데이터를 조회할 때 데이터 I/O량이 너무 많아서..

- 반정규화 기법

  - 테이블의 반정규화 , 수직수평분할 1:1,m 관계 테이블 병합, 중복통계이력부분 테이블 추가..등..
  - 칼럼의 반정규화, 중복칼럼 추가, 파생칼럼,pk에 대한 칼럼 추가등등

- 정규화는 중복된 데이터를 제거하는 과정임 

  1차 정규화 : 각 로우(가로) 마다 하나의 속성값을 갖도록 설정

  2차 정규화 : 모든 컬럼이 완전 함수적 종속을 만족하도록, 부분적 종속이 없어지도록 정규화 하는 것, 테이블을 분리한다.

  3차 정규화 : 이행적 함수 종속이 없어지도록 하는 것, pk에 의존하지 않고, 일반 칼럼에 의존하는 컬럼들을 분리하는 것

  BCNF : 3차 정규화에 좀더 강화된 버젼.

- 파티셔닝
   - 데이터 엑세스 성능을 향상시키기 위한 방법
   - 논리적으로는 하나의 테이블이지만, 물ㄹ리적으로 여러개의 테이블로 분리하는 방법
- 논리테이터모델
   - 슈퍼, 서브 타입
   - 트랜잭션은 항상 전체를 통합,분석처리하는데, 테이블이 하나로 통합되어 있으면 데이터 집적으로 성능 향상(조인 감소)

- union all vs union
   - union = union distinct, 중복제거함
   - union all  중복제거하지 않음
- 상수값으로 equal 조건이 조회되는 컬럼은 가장 먼저 순서로 인덱스를 생성하는 것이 좋다
- 엔티티 간에 논리관계에 있을 때는, 상호조인이 발생한다는 의미고, 이럴경우 DBMS에서 FKㅏ생성과 상관 없이 조인 성능을 향상시키키 위해 인덱스를 생성하는 것이 좋다.

- GSI는 통합데이터베이스를 의미한다. 분산 데이터 베이스 시스템 기반이 아니다.



### 2

- DML 데이터 조작어
   - Select, insert, delete, update
- DDL 데이터 정의어
   - Create, alter, drop, rename
- DCL 데이터 제어어
   - Grant, Revoke
- TCL 트랜잭션 제어어
   - Commit, Rollback



- 절차적 조작어 : how , 어떻게 데이터를 접근해야 하는지 PL/SQL(오라클) , T-SQL(SQL-Server)
- 비절차적 조작어 
   - As-ls 사용자가 무슨 데이터를 원하는지
   - To-be 사용자가 무슨 데이터를 원하는지 

- PK조건 생성(oracle 기준)

   ```sql
   constraint PRODUCT_PK primary key(product_id)
   ```

   

- NULL

   - 모르는 값

   - 값의 부재

   - NULL과의 모든 비교는 Unknown을 반환한다.

   - 집계함수(count..)는 null을 체크하지 않는다.

   - 널이 아닌 경우를 찾는 방법? where column is not null 

      혹은 널인 경우 찾을 때는 is null

- 제약조건 종류
   1. PRIMARY KEY 기본키 : UNIQUE + NOT NULL, 테이블당 1개만 생성
   2. UNIQUE KEY 고유키 : 유일하지만 NULL값은 입력할 수 있음
   3. NOT NULL
   4. CHECK : 데이터 무결성을 유지하기위해, 특정 컬럼에 설정하는 제약
   5. FOREIGN KEY 외래키 : 테이블당 여러개 생성 가능, null값을 가질 수 있다
- 참조무결성 제약조건
   - 데이터 무결성, 일관성
   - 다른 관계 변수의 외래 키에 의해 참조되는 쌍(dupe 행)을 제거하는 것은 참조 무결성을 파괴해 버리게 되기 때문에 [관계 데이터베이스 관리 시스템](https://ko.wikipedia.org/wiki/관계_데이터베이스_관리_시스템)(RDBMS) 참조 무결성을 유지하도록 일반적으로 삭제를 방지



- ALTER TABLE EMP Drop Column COMM;

- RENAME STADIUM TO STADIUM_JSC;

- 참조동작
   - RESTRICT : child 테이블 pk값 없는 경우에만 master 삭제를 허용
   - AUTOMATIC : Master table pk없으면 자동생성
   - DEPENDENT : Master table PK 존재할 경우에만 Child 입력을 허용

- TRUNCATE
   - 모두 삭제 + 용량 초기화
   - 로그를 남기지 않고 테이블을 초기화(삭제)
   - DELETE 보다 빠르다 왜? 로그를 남기지 않으므로
   - AUTO COMMIT
- DROP
   - 로그를 남기지 않고, 테이블을 삭제
   - 모두 삭제 + 용량 초기화 + 스키마 삭제
   - 테이블 정의 자체를 삭제
   - AUTO COMMIT
- DELETE
   - 모두 삭제만
   - 로그를 남기고 테이블을 삭제
   - 사용자 COMMIT

- DISTINCT
   - Select에서 겹치는 것을 한번만 가져오기 위해서 distinct 조건을 주면됨



- 트랜잭션 특징
   - 원자성 : all or nothing. 실행되던지 아니던지
   - 일관성 : 트랜잭션 실행 전 데이터베이스가 잘못되어있지 않으면, 실행 후 에도 잘못되서는 안됨
   - 고립성 : 트랜잭션 실행 중에는 다른 트랜잭션의 영향을 받아 잘못된 결과를 만들어서는 안됨
   - 지속성 : 트랜잭션이 수행되면 갱신한 데이터베이스는 영구적으로 저장

- Dirty read : 트랜잭션이 수행되었지만 아직 커밋되지 않은 데이터를 읽음
- non-repeadtable read : 한 트랜잭션 내에서 같은 쿼리를 두번 수행해는데, 그 사이에 다른 트랜잭션이 값을 수정 삭제하여서 두 쿼리 결과가 다르게 나옴
- phanthom read 한 트랜잭션 내에서 같은 쿼리를 두번 수행했는데 첫번째 쿼리에서는 없었던 유령 레코드가 두번째 쿼리에서 나타나는 현상



- Oracle - DDL (데이터 정의어 create, alter... drop rename) - 자동 커밋

- SQL -DDL - 자동커밋이 아님

- Oracle sql에서는 '' 라고 입력시 null로 들어감 조회할 때는 ''가 아닌 null로 해야함

   SQL server에서는 '' 라고 입력시 공백으로 들어가고 , 조회도 가능함. 다만 데이터는 조회되지 않음



- 내장함수 or 사용자 함수
   - 내장 함수 --- 단일행 함수 or 다중행 함수
      - 다중행함수 --- 집계 함수 or 그룹 함수 or 윈도우 함수

- 다중행 함수는 단일 값만 반환
- 단일행 함수는 select, where, order by , update의 set절에 사용이 가능



- 1/24/60 = 1분을 의미 1/24/(60/10) 10분



- 서브쿼리

   select절에 있으면? 스칼라 서브쿼리

   from절에 있으면? 인라인 뷰

   where절에 있으면? 서브쿼리

- 스칼라 서브쿼리
   - select문에 사용하는 서브쿼리로, 1행만 반환하는 특징을 가졌음
- 상호 연관 서브쿼리 (correlated subquery)
   - 메인쿼리의 값을 서브쿼리가 사용하고, 서브쿼리의 값을 받아서 메인쿼리가 계산하는 구조

- 단일행 NULL관련
   - NVL(표현식 1, 표현식2),ISNULL(표현식1, 표현식2  
      - 표현식 1 결과값이  NULL이면 표현식 2의 값을 출력
      - 단 표현식1, 표현식2 데이터 타입이 같아야함
   - NULLIF(표현식1, 표현식2) 
      - 표현식1, 2가 같으면 NULL을 같지 않으면 표현식1을 리턴함
   - COALESCE(표현식1,표현식2...)
      - 임의의 개수 표현식에서, NULL이 아닌 최초의 값을 나타낸다 
      - 모든 표현식이 NULL이면 NULL을 리턴
- GROUP BY 절에는 alias 사용 불가,
   - GROUP BY절에 사용된 컬럼이 SELECT절에 사용되어서는 안됨
- WHERE 절에는 집계함수가 올 수 없음
- HAVING은 GROUP BY 절에 와야함,  HAVING 단독으로도 올 수 있음
- 일자가 가장 빠르다? MIN함수
- 기본 정렬은 오름차순
- Oracle에서는 NULL값을 가장 큰 값으로 간주
   - 반면 SQL server에서는 NULL값을 가장 작은 값으로 간주

- SELECT 문장 실행 순서
   - F W G H S O
   - From Where Group by Having Select Order by

- 동일한 순위 출력?
   - with ties...
- 상위 몇명?
   - top(...)

- 최소 필요한 join 조건?
   - 테이블 갯수 -1

- 조인

   - 일반적으로 조인은 pk, fk값의 연관성에 의해 성립됨
   - DBMS 옵티마이저는 FROM 절에 나열된 테이블들을 항상 2개정도로 묶어서 JOIN처리함
   - EQUI 조인은 = 연산자에 의해서 수행됨. 그 이외의 비교 연산자를 사용하는 경우는 모두 non equi 조인

   - 대부분 non equi 조인 수행할 수 있지만 때로는 설계상의 이유로 수행 불가능경우도 있음



- 순수 관계 연산자?
   - select, project, join, division