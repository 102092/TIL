> https://www.youtube.com/watch?v=dJ5C4qRqAgA
>
> https://www.slideshare.net/baejjae93/ss-151545329



## 의존성

- dependency

- A --->(depends-on) B
  - B가 바뀌었을 때, A가 바뀔 **가능성** 이 있어요 라고 알려주는 것.
- 의존성은 변경과 관련된 것.
- 의존성이 있다고 해서 **항상, 반드시** 성립되는 것은 아니다.
- 의존성은 크게 2가지
  - 클래스 사이에
  - 패키지 사이에



#### 클래스 사이에 의존성

##### 연관관계

- A -> B
- Association
- 영구적인 경로가 있음.



##### 의존관계

- A --> B
- 일시적인 경로가 있음.
- Dependency



##### 상속관계

- A - :arrow_forward: B
  - 큰 화살표!
- inhritance
- extends



##### 실체화 관계

- A --:arrow_forward:B
  - 큰 화살표!
- implements



#### 패키지 의존성

- 패키지 A의 어떤 클래스가 바뀔때, 패키지 B의 클래스가 영향을 받으면
- 의존성이 있다고 생각한다.



### 좋은 의존성을 위한 규칙

#### 양방향 의존성을 피하라

- B가 바뀔때, A도 바뀌고, A가 바뀔때, B도 바뀐다.
- 하나의 클래스를 어거지로 찢어놓은 것으로 보임.
- 굉장히 신경쓸 게 많기 때문에, 가급적이면 이 관계는 지양한다.
- 성능이슈도 생김



#### 다중성이 적은 뱡향을 선택하자

#### 의존성이 필요 없다면, 제거하자.

#### 패키지 사이에는 양방향 의존성이 있으면 안된다.





## 주문 Validation

- 장바구니에 담으면 서버에 보내는 것이 아니라, 앱에서 저장한다.
- 서버에 보내기 전에 많은 검정 과정을 거친다.

- 즉 객체간에 엄청나게 많은 소통을 할 것임.

![](https://image.slidesharecdn.com/woowahan-oo-190624161343/95/-37-1024.jpg?cb=1561392949)

- 이걸 어떻게 코드로 표현할 것인가?
  - 동적인 소통을, 정적인 코드로 어떻게 변환할 것인가?

![](https://image.slidesharecdn.com/woowahan-oo-190624161343/95/-38-1024.jpg?cb=1561392949)

- 객체간의 협력 방향을 기반으로, 의존성을 어떻게 설정할것인지 결정한다.

  

### 연관관계

- 탐색 가능성.
- Order 라는 객체를 통해서, 어떤 방식이든, OrderLineItem으로 찾아갈 수 있다.
- 이러한 관계를 잡는 것은, 두 객체간의 통로가 **영구적으로** 유지되어야되는 이유가 있어아함.
- 일반적으로는 *객체 참조* 를 이용하여 연관관계를 구현.



## 설계 개선하기

- 의존성을 살펴봐야한다.
  - 의존성 사이클이 돌고 있는가?
  - 무슨말?

- 의존성 역전 원리
  - 구체적인 클래스에 의존하지 말고, 추상적인 것에 의존하세요
  - 추상적인 것? 
    - 잘 변하지 않는 것.

- 연관관계 다시 살펴봐라
  - 연관관계가 있다면, 어디까지 조회하게 할 것인가?
  - 그러다보면 `Lazy Loading Issue`가 발생
  - 이 걸 다시 말하면, 트랜잭션에 경계는 어디까지 갈것인가?
    - 트랜잭션의 덩어리가 커지면, 좋지 않음.

- 트랜잭션 경합 때문에 성능이 저하 된다.
  - 그러다보면 객체 참조가 필요한가? 라는 근본적인 의문이 생기기도 함.

- 객체 참조는 결합도가 가장 높은 의존성!

- 필요한 경우에는 객체 참조를 다 끊어 버려야함.



### Repsotiory를 통한 탐색

- 약한 결합도임.
- 연관관계를 통해서 탐색할 수 있는 메서드만 , Repository에 들어가야함.



### 모든 객체 참조가, 불필요하진 않음

- 같이 생성되고, 같이 제거되는 객체들은 같이 묶어야함.
  - 그렇지 않은 경우는 끊어라
- 도메인 제약사항을 공유하는 경우는, 함께 묶어야함.
- 어떤 객체를 어떻게 묶을것인가는, 정해진 룰이 없음.
  - 각자 비즈니스 룰에 따라서 결정됨.

- 객체관계를 끊고 나면, 이 단위로 트랜잭션을 관리해주면 됨.



### 객체 안에, validation 을 항상 포함할 필요는 없음

- 주문에 대한 validation은 따로 빼서 모아놓는 것이 나을 수도.



### Domain Event 발행

- `AbstractAggregateRoot class`
  - `registerEvent` 메서드를 사용함.
  - 비동기, 동기 모두 선택 가능



### 패키지를 나눌 때는, 도메인에 대한 관점이 바뀔 때가 많다.

