>  todo

- 알고리즘, 자료구조

  - [x] 백준 수학 기초 1문제
    - [ ] youtube 바바킹 1강
  - [ ] youtube ds binary heap 정리
  - [ ] 자바 sort 정렬 notion에 정리해보기
- CS
- 강의
  - [ ] 호눅스 강의 쿼리 최적화 다시보기
  - [ ] 호눅스 Redis 다시 듣기
  - [ ] 호눅스 devOps 다시 듣고 정리
  
- posting

  - [ ] airbnb11 프로젝트 정리
- etc



> issue-today

- [ ] JPA Mapping 에 대해 정리

- [x] issue-label refactoring

- [ ] assignee 연결

- [x] interceptor 만들기



> 호눅스 알고리즘 2



### 그래프 및 완전 탐색

- Edge와 Vertices로 구성된 자료구조를 그래프라 한다.
- 그래프는 트리와 비슷함.
- 일반적으로 Edge에 가중치 weight가 들어간다.
- 지하철 노선도가 그래프와 비슷하다.

- 일상생활에서 볼 수 있는 트리
  - 폴더, 조직도..
- 그럼 트리와 그래프의 차이는?
  - 트리는 단방향, 사이클이 만들어지지 않는다.
  - 그래프는 양방향, 사이클이 만들어진다.
- 그래프를 표현하는 방법은.
  1. 인접 배열로 
  2. 인접 리스트로 

- 사이클이 없으면, 다시 돌아올 수 없음.
- 사이클이 있으면 다시 돌아올 수 있다.

- 8가지 경우의 수가 있음.



### 그래프 복잡도

| Operation       | Adjacency List(인접 배열) | Adjacency Matrix(인접 매트릭스) |
| --------------- | ------------------------- | ------------------------------- |
| Storage Space   | O(V + E)                  | O(V^2)                          |
| Add Vertex      | O(1)                      | O(V^2)                          |
| Add Edge        | O(1)                      | O(1)                            |
| Check Adjacency | O(V)                      | O(1)                            |

- V는 vertices
- V^2 처음 확장할 때 매트릭스가 V^2만큼 필요하니까,
- Introduction Algorithm 책 필요
- 배열이라는데 굉장히 단순한 자료구조여서 실수할 여지가 적다



### 주요 그래프 알고리즘

- BFS, DFS, 완전탐색 + 백트래킹
  - 너비 우선 탐색, 깊이 우선 탐색
  - 참고로 트리의 탐색은? pre , in, post
- 위상 정렬
  - 위상 정렬인걸 알면, 1초만에 풀리고
  - 모르면 못푸는
  - 컨셉이라도 기억하고, 한 두문제 풀어보자
- MST 문제
  - Minium Spening Tree
  - 기본적으로 기출적인 그래프
  - 통과
- 다익스트라 최단거리 알고리즘
  - 4가지
  - 최단거리 : 벨만코드, 다익스트라, 플로이드와샬, 에이스타
  - 벨만코드는 어렵지 않음 스스로 공부하자
  - 다익스트라 쉽다. 오늘 해보자
- 플로이드 알고리즘
- A+ 알고리즘
  - 게임에서 많이 쓰는 알고리즘
  - 굉장히 재밌다.
  - 유투브 강좌도 많다.



> 주요 코드는 GeeksForGeeks에서 찾아볼 것!!!



### BFS

- 넓이 우선 탐색
  - 나랑 가까운 우선 순 대로 탐색한다.
- visualgo.net
- 알고리즘 도감
  - 책을 살바에는 앱을 사는게 낫다
  - 3500원정도의 가치는 있다.

- BFS 구현하기 위해서는 `queue` 가 필요하고 DFS는 `stack` 이 필요하다
  - DFS는 재귀로 구현이 가능하다. 그리고 쉽다.
- call stack 기본적으로 코드 실행시 주어지는 스택

> sudo code

```java
알고리즘 BFS(u):

Q = {u} //queue

while not Q.empty  
    u = Q.pop //뽑아서
    for each neighbor v of u: //내 이웃들을 뒤져보는데
        if v is unvisited, tree edge, Q.push(v) //방문하지 않았다면 큐에 넣는다
        else ignore this edge 
          
//전부다 방문했고, queue가 비어있으면 알고리즘이 끝난다.
```

- BFS는 어디서 사용할까?
  - 가중치 없는 그래프에서 최단거리를 알아낼 때 사용한다.
  - 몇변 BFS를 호출했는지 카운트 해서, 몇 depth만에 도달했는지 알아내는 방법



### DFS

- 깊이 우선 탐색
- 스택, 재귀로 구현
  - 일단 갈 수 있는 곳까지 방문하고 막혀있으면 다음 시작점에서 다시 방문하는 방식

```java
dfs(u):
    visited(u) = True
    for each neighber v of u:
        if v is not visited:
            dfs(v)
```





### 위상정렬

- topological sort 
- 정렬이 아니다...
- 그래프를 방향성을 잃지 않고, 나열하는 방법을 의미한다.
  - 방향성이 있어야하고,
  - 사이클이 있으면 사용이 불가능 하다.

- 이걸 알면 너무 쉽게 풀리는 알고리즘 문제들이 많다
- DFS와는 다르다!
  - 예를 들면, 게임 스킬 배우는 데, 먼저 배워야할 스킬들이 있는 경우?
  - A->B에 의존 하고 ,B->C에 의존하는 경우
    - A -- B -- C 이렇게 출력되어야함.

- 어떻게 구현해야할까?
  - DFS는 한다음에, 뒤집어서 출력하면 됨.
  - DFS + stack을 이용해서 구현하면 가장 쉽다.

- 참고
  - https://jason9319.tistory.com/93
  - https://www.geeksforgeeks.org/topological-sorting/
  - https://www.acmicpc.net/problem/2252



### 다익스트라 최단거리

- 그리디 알고리즘과 다이나믹프로그래밍을 이용해서 최단거리를 구한다.
  - 그리디 알고리즘 , 당장 어떻게 될지 모르겠지만 눈 앞의 이득을 찾아가는 것.
  - 현실세계에서는 그리디 한게 먹이는 경우가 많음.
- suboptional practical
  - 부분의 최적이 전체의 최적이 됨을 보장해주는 경우
- 다이다믹 프로그래밍?
  - 기존에 알고있던 답을 메모장에 적어놨다가, 새로운 답을 구하는데 사용하는 것.
  - 동적 계획법, 동적 프로그래밍
- 비용이 음수가 되는 경우에는 해당 알고리즘을 사용할 수 없음.
- [ ] 피보나치 수열 동적 프로그래밍으로 구해보기



### 벨만 포드 알고리즘

- 음의 가중치가 있어도 최단거리를 구할 수 있음.



### 플로이드 알고리즘

- 음의 가중치에도 적용가능하고
- 모든 점간 경로들의 최단 거리 를 구한다.



### 완전 탐색

- Brute force
- 모든 경우를 다 따지는 것.
- DFS, BFS에서도 사용한다.
  - 둘다 사용할 수 있을 때는 DFS 사용하는게 쉽다.



### 백트래킹

- 완전탐색을 했더니, 시간 초과가 날때 사용하는 방법
- 해답을 찾지 못할 것 같으면, 혹은 종료 조건을 만난 경우, 이전 상태로 돌아가서 재탐색을 개시하는 방법
- 카카오 2번 문제
- N-Queen
- 주로 DFS를 가지고 많이 함.