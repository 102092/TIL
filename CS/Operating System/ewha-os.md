## 출처

- http://www.kocw.net/home/search/kemView.do?kemId=1046323



## 목표

- 운영체제는 컴퓨터 하드웨어 위에, 설치되는 필수적인 소프트웨어 계층
  - 어떻게 컴퓨터 운영에 있어 도움이 될것인가?



## 1. 운영체제란?

![1570104116901](ewha-os.assets/1570104116901.png)

- 기능은 뭐가있을까?

  1. 하드웨어랑 어떻게 교류할까?
  2. 소프트웨어랑, 사용자랑 어떻게 교류할까?

  - 이 두가지가 운영체제 과목을 배우는 목적.

- 즉 운영체제는 컴퓨터 시스템을 편하게 사용할 수 있게하는 목적을 가진다.

  - 컴퓨터자원을 **효율적으로 관리하게 도와주는 역할**을 하는 것이 운영체제

- **협의의 운영체제(커널)**

  - 좁은 의미의 운영체제

  - 항상 메모리에 상주하는 부분

- **광의의 운영체제**

  - 커널뿐만 아니라 각종 주변 시스템 유틸리티 포함

  

- 다수의 프로그램이, 메모리를 요구할 경우 어떻게 운영체제는 <u>자원을 할당</u>할 것인가?

  - 형평성 있는 자원 분배
  - 효율성 있는 자원 관리

- 운영체제는 하드웨어(프로세스, 기억장치) 자원뿐 아니라, 소프트웨어 자원(파일...)도 관리해야함



![1570104521077](ewha-os.assets/1570104521077.png)

- CPU는 굉장히 빠른 자원.
  - 프로그램마다 하나의 자원을 할당하는 행동을 반복함.
  - 그 행동이 너무 빨라서, 사람들이 이용할 때는 지연을 느끼지 못한다.



### 운영체제 분류

1. 동시 작업 가능 여부

- 단일 작업(과거 운영체제)
  - single tasking
- 다중 작업(현대적인 운영체제)
  - multi tasking
  - 유닉스, 윈도우즈, IOS...



2. 사용자의 수

- 단일 사용자
  - 단일 작업만 지원해주는 과거 운영체제..
  - MS-DOS, 
- 다중 사용자
  - 하나의 서버에서, 다중 계정을 통해 작업을 할 수 있는 운영체제
  - UNIX, NT server



3. 처리방식

- 일괄 처리(batch processing)

  ![1570105399350](ewha-os.assets/1570105399350.png)

  - 작업을 모아서 처리.
  - 과거 방식 , 이 때는 이게 가장 효율적이였음..



- 시분할(time sharing)

  ![1570105425550](ewha-os.assets/1570105425550.png)

  - 시간 별로 작업을 처리
  - 일괄 처리 보다는 **짦은 응답시간!**
  - 여러 작업을 수행할 떄, 컴퓨터 작업능력을, 일정시간 단위로 분할하여 사용할 때
  - 그러나 사용자가 많아지만, 일정시간이 늘어날 수 있음.
    - 목적은 여러사람이 이용할 수 있게, 자원을 효율적으로 배분하는 것

  

- 실시간(RealTime OS)

  - 실시간 == 시분할?? : Nope
  - deadline이 있어서, 정해진 시간 안에 결과가 나오는 것을 보장해주는 운영체제
  - 즉 특수한 목적을 가진 시스템에서 사용됨 ex) 원자로/ 공장제어, 미사일 제어, 반도체... 로보트 제어등등.
  - Hard realtime system 경성 실시간 시스템 == 무조건 지켜라
  - Soft realtime system 연성 실시간 시스템 == 시간을 지키지않으면, 치명적인 결과를 초래하진 않지만 이용하는 사람이 기분이 나쁠 수 있음..(넷플리스에서 실시간으로 영화를 볼때 )

  

### 생각할점

- 지금 사용하는 운영체제는 **다중 사용, 다중 작업, 시분할** 로 이루어지고 있다는 점.



### 용어

- Multitasking 
- Multiprogramming : 메모리에 여러 프로그램이 동시에 올라가는 것, 멀티태스킹이 되려면, 멀티 프로그래밍이 되어야하지만, 이 용어는 메모리 측면을 강조한 언어
- Time sharing : 멀티태스킹과 유사. 그렇지만 CPU쪽을 강조하는, CPU의 시간을 분할해서 사용한다는 의미.
- Multiprocess : 위와 유사함 



- Multiprocessor : 위 4개와는 조금 다름. 하나의 컴퓨터에 CPU가 여러개 붙어있는 의미.
  - 멀티 프로세서가 지원되고, CPU가 여러개 있음. 병렬적으로 시스템을 실행시킬 수 있음.



### 운영체제의 예

1. UNIX
   - 서버를 위한 운영체제
   - 코드 복잡 만들기 어려움. 왜? 어셈블리 언어(기계어에 가까운 언어)로 되어있어서.. 이 점을 대체하기 위해 C언어(고급 언어, 그러면서 기계어와 상당히 가까운 언어)를 만듬.
   - 다른 컴퓨터에 이식하기 쉬움. 왜? C언어로 작성되어있어서 컴파일 하면 다른 컴퓨터에서도 이해할 수 있게됨
   - 최소한의 커널(항상 메모리에 상주하는)
   - Linux...
2. MS Windows
   - 개인 컴퓨터 목적
   - 단일 작업, 단일 사용자 목적



### 운영체제의 구조

![1570106738172](ewha-os.assets/1570106738172.png)

- CPU 스케쥴링 : 누구한테 CPU 시간을 할당할까?... 짦은 시간 간격으로 시간을 줬다 뺐었다함.
- 메모리 관리 : 한정된 메모리를 어떻게 쪼갤까? 공평하게 ? 많이 쓰는 애한테 많이 줘야하나? 

- 파일 관리 : 디스크에 파일을 어떻게 보관할까?, 어떻게 하면은 Disk 헤드의 움직임을 최소화하면서 빠르게 요청을 처리할 수 있을까?

- 입출력 관리 : 각기 다른 입출력 장치와 컴퓨터 간에 정보를 어떻게 주고 받게 할까? 



## 2. System Structure & Program Execution

- 운영체제 설명에 앞서, 컴퓨터 하드웨어의 동작에 대한 강좌.

  

### 컴퓨터 시스템 구조

![1570191871323](ewha-os.assets/1570191871323.png)

- I/O ? input, output

- Memory : CPU의 작업공간, CPU는 <u>매클럭사이클 마다, 메모리에서 기계어를 읽어서 실행</u>시키게 됨

- DISK : I/O device 

  

  ![1570192126626](ewha-os.assets/1570192126626.png)

- registers
  
- PC : program conter , cpu가 실행시킬 다음 작업의 메모리 주소를 가지고 있음.
  
- 각 I/O device마다 컨트롤러가 붙어 있어서, 작은 CPU 역할을 하고 있음.

- local buffer? 각 device의 작업공간

- mode bit : cpu에서 실행시키는 것이 운영체제 인지 사용자 프로그램인지 구분

  CPU는 메모리하고만 일하니까.  I/O device에는 접근 안함. 

  - 그러면 Disk에서 읽어오라는 요청은 어떻게 처리함?
  - CPU가 직접 Disk에 접근하지 않고 device controller에게 하라고 시킴
  - 이 작업을 interrupt line을 통해

- timer : 특정 프로그램이 CPU를 독점하는 것을 막기 위함.

  - CPU에 프로그램을 넘겨줄 때, timer를 설정하고 넘겨주기 때문에, 이 제한 시간을 넘기면 cpu에게 interrupt 를 걸음.
  - CPU는 interrupt line을 체크하여, OS에게 권한을 넘겨서 다음 프로그램으로 작업이 넘어감.

- 프로그램일 실행하다가 I/O 요청이 오면?

  - controller가 interrupt를 걸고, CPU는 운영체제에게 넘어가고, 운영체제는 왜 interrupt가 걸렸는 지 확인하고, I/O 프로그램 때문이라는 것을 확인하고 CPU를 할당하고
  - 끝나면, interrupt이전 작업에게 다시 CPU에게 할당하고



- Mode bit
  - **0이면?** 운영체제가 cpu를 가지고 있을 때는, 모든 작업을 실행할 수 있게 되어있음.
  - **1이면?** 사용자 프로그램이 cpu를 가지고 있을 때는, **제한,한정된 작업 실행**
  - interrupt가 들어오면 mode bit은 자동으로 0으로 바뀌게 됨.
  - 왜 필요?
    - 사용자 프로그램의 잘못된 수행으로 다른 프로그램 및 운영체제에 피해가 가지 않도록 하기 위함
  - 모니터 모드?
    - ==커널모드, 시스템 모드
- Timer
  - 하드웨어
  - 특정 프로그램이 cpu를 독점하는 것을 막기 위해.
  - 정해진 시간이 흐른 뒤에 운영체제에게 CPU제어권이 넘어가도록 타이머를 걸어놓은 것



- Device Controller
  - I/O 장치를 관리하는 작은 CPU, 하드웨어 장치
  - local buffer 가짐 

- Device Driver
  - CPU가 실행하는 장치들을 작동시키지 위한 코드를 가지고 있음.



- DMA controller
  - Direct Memory Access Controller
  - 메모리에 접근할 수 있는 컨트롤러. 
    - 원래는 메모리에 접근할 수 있는 것은 CPU 단독이지만,
    - memory controller도 접근할 수 있기에, 중재하는 역할
  - 또한, 중간중간에 들어오는  cpu로 향한 interrupt가 될 작업들을 가지고 있다가 한번에 메모리에 올려 interrupt를 걸고 알려주는 역할



### 인터럽트

- 하드웨어가 거는 interrupt , **timer** , **I/O controller**
  - 일반적인 인터럽트
- 소프트웨어가 거는 interrupt : **trap**
  - System call, Exception...
- 인터럽트 벡터
  - 인터럽트 종류(**번호**)마다 어디에 있는 함수를 실행시켜하는 지 **주소**를 적어놓은 것
- 인터럽트 처리 루틴
  - 인터럽트 종류마다 할일이 다르니까. 이러한 일을 운영체제에 저장해 놨음



### 입출력

- 모든 입출력 명령은 특권 명령

  ![1570193782454](ewha-os.assets/1570193782454.png)

- 요청은 하드웨어 인터럽트를 통해, 요청이 다 끝나면 소프트웨어 인터럽트(트랩)

- 운영체제는 cpu를 사용할 일이 없음. 인터럽트가 들어올 때만 cpu운영권한을 얻지 그렇지 않으면 항상 사용자 프로그램만 돌리고 있음.



### 시스템 콜

- 사용자 프로그램이 운영체제의 서비스를 받기 위해 커널 함수를 호출 하는 것.
- 운영체제 함수를 호출하는 것. CPU제어권이 운영체제에게 넘어가게 하는 것.



### 동기식 입출력, 비동기식 입출력

- synchronous I/O

  - I/O 요청 후, 입출력 작업이 완료 된 후에야 제어가 사용자 프로그램에게 넘어감.

  ![1570194748972](ewha-os.assets/1570194748972.png)

  - I/O요청이 끝났음을 interrupt를 통해 알려줌.
  - 요청이 끝날 때 까지, 기다려야하는 방식
    - 그러면 자원이 낭비되지 않을까?
    - **보통 동기식 입출력을 구현**할 때, 방법 2를 사용함.

- asynchronous I/O
  - I/O가 시작된 후, 입출력 작업이 끝나기를 기다리지 않고 제어가 사용자 프로그램에게 넘어가는 것.
  - 요청이 끝나기 전에도, 다른 일을 시작하는 방식

- 예시

  ![1570194796176](ewha-os.assets/1570194796176.png)
  
  - 동기식 입출력 
    - 프로세스가 입출력 요청을 함 -> 운영체제 -> 컨트롤러
    - 입출력이 끝나는 동안 프로세스는 아무것도 안하면 **동기식 입출력**
  - 비동기식 입출력
    - 입출력이 끝나기 전에, 프로세스가 instruction을 실행하게 되면 비동기식 입출력.

### 서로 다른 입출력 명령어

![1570195271461](ewha-os.assets/1570195271461.png)

- 왼쪽

1. 메모리 접근하는 명령어
2. I/O device에 접근하는 명령어



- 오른쪽

1. I/O장치도, 메모리 주소에 연장주소를 붙인다음에 메모리 접근하는 명령어를 통해 접근 할 수 있게함.
   - Memory mapped I/O



- 왜 다르게 했을까?



### 저장장치 계층 구조

![1570195367918](ewha-os.assets/1570195367918.png)

- 특징 : 위로 갈 수록 속도가 빠름. 
  - 그렇지만 가격도 비싸고, 용량이 작음.
- 연두색 : 휘발성 매체
  - 분홍색 : 비휘발성 매체
- byte 단위 접근할 수 있는 Primary, Executable한
  - CPU에 직접 접근하지 못하는 개체 : Secondary

- Caching : 다른 매체를 통해 데이터를 읽어서 사용하는 것.
  - 그렇지만 밑에서 모든 것을 다 읽진 못함. 위로 갈수록 용량이 작아지니까.. 
  - 이것을 어떻게 관리해야 되는지가 포인트.



### 프로그램의 실행 (메모리 load)

![1570195644592](ewha-os.assets/1570195644592.png)

1. 파일시스템 : 실행파일
2. virtual memory
   - code : 기계어
   - data : 자료구조
   - stack : 함수를 호출할 때 데이터를 쌓는 용도
3. 프로세스로



- virtual memory에 있는 것을 모두 다 physical memory에 올리는 것이 아니라 , 필요한 일부분만 올림. 메모리를 효율적으로 사용하기 위해서
- 꼭 필요하지 않은 부분은 Swap area에 내려놓음.
- 즉 그림에 보이는 것처럼 Virtual memeory에 모여있는 것이 아니라, 일부분은 Physical memory에 일부분은 Swap area에 있음.

- Swap area : 휘발성. 메모리 관리를 위한 공간.
- File system : 비휘발성. 파일 관리를 위한 공간.



### 커널 주소 공간 내용

![1570195895746](ewha-os.assets/1570195895746.png)

- process controller block
- 사용자 프로그램마다 따로 커널 스택을 가지고 있음.



### 사용자 프로그램이 사용하는 함수

- 함수
  - 사용자 정의함수
  - 라이브러리 함수
  - 커널 함수
    - 운영체제 프로그램의 함수
    - 커널 함수가호출되는 것은 시스템 콜을 의미한다.

![1570196128928](ewha-os.assets/1570196128928.png)

- 프로스세 A의 address space에서 Kenel Address space로 점푸하지는 못함.



### 프로그램의 실행

![1570196218982](ewha-os.assets/1570196218982.png)

- 유저모드에서 실행이 됨.
- 시스템 콜을 하게 되면, 운영체제 커널 주소 공간에 있는 코드가 실행되고
- 시스템 콜이 끝나게 되면, A라는 프로그램에게 CPU제어권이 넘어가고, 
- 본인 코드 주소에 있는 코드를 실행하게 됨.
- 즉 프로그램의 실행은 유저 <-> 커널 모드 하면서 실행됨을 알 수 있음.



## 3. 프로세스

- program in execution

  - 실행중인 프로그램을 일컫는 말.

- 프로세스의 문맥

  - 특정 시점을 놓고 봤을 때, 어디까지 수행을 했고 어디까지 와있는가?
    - 이게 왜 필요해? 연속되어 실행될 수 있게 하려고...?

  1. 하드웨어 문맥  : 레지스터가 어떤 값을 가지고 있는가?
  2. 프로세스의 주소 공간 : code, data, stack에 어떤 값이 들어가 있는가?
  3. 프로세스 관련 커널 자료 구조 : PCB(Process Control Block)



### Process State 

- 컴퓨터 내부에 CPU는 1개로 정의

1. Running
   
   - CPU를 잡고, instuction을 수행 중인 상태
2. Ready
   - CPU를 잡기 위해 대기하고 있는 상태
   - 다른 모든 준비는 끝나있고, CPU만 얻기를 기다리고 있음. 보통 이 상태에 있는 프로그램들이 CPU를 잡았다 놨다 하면서 실행됨.
3. Blocked
   
   - CPU를 주어도 당장 instruction이 불가능한 상태 (= 시간이 오래걸리는 I/O 작업들)
4. Suspended
   - CPU뿐만 아니라, 외부에서 이 시스템을 강제로 정지해놓은 상태
   - **중기 스케쥴러**와 함께 알아야한 프로세스의 상태

5. etc

   - new : 프로세스가 생성중인 상태

   - terminated : 수행이 끝났음. 그렇지만 정리가 필요한 상태

   

- Blocked 는 자기 자신이 요청한 상태, event가 만족되면 Ready상태로 돌아감
- Suspended는 반면여, 외부에서 요청한 상태로, 외부에서 resume을 해줘야 Active함

6. 프로세스 상태도

![1570536775043](ewha-os.assets/1570536775043.png)

​	

![1570536856956](ewha-os.assets/1570536856956.png)

- 프로세스가 디스크에서 무언가 읽어야 한다? Running 상태에서 blocked상태로 변함
  ![1570538366564](ewha-os.assets/1570538366564.png)

  - 사용자모드에서 코드 실행 중인 상태

  - 프로세스가 자기 코드를 실행하다가, 콜해서 운영체제 코드가 실행 중이면 이 프로세스가 커널모드에서 run하고 있는 상태라고 부름

  - interrupt 해서, 운영체제 코드가 실행 중이면, monitor mode에 들어갔다고 함.

    ​	![1570538576703](ewha-os.assets/1570538576703.png)

  - 점선 아랫 부분은 inactive한 상태. 외부에서 간섭으로 인해서. 프로세스가 얼어붙어있는 상태

  

### Context Switch

- CPU가 한 프로세스에서 다른 프로세스로 넘겨주는 과정을 일컫는 말.

  ![1570537231834](ewha-os.assets/1570537231834.png)

- CPU를 뺐었으면,운영체제가 프로세스가 다시 실행될 때 어디까지 실행되었는 지 기억할 수 있도록 함.
- 어디에다가? 실행되고 있던 프로세스의 **PCB**에다가!

- System call : 운영체제가 CPU에게 요청하는 것

- Interrupt : 하드웨어 , 컨트롤러가 CPU에게 거는 것

  - System call, Interrupt가 발생시 반드시 context switch가 일어나는 것은 아님.

  ![1570537437586](ewha-os.assets/1570537437586.png)

  - 1번 은 문맥교환 아니고, 2번은 문맥교환임.
  - 차이는 중단된 프로세스가 interrupt of system call 이후에 그대로 지속되었는가?
  - 즉 프로세스 자체가 바뀌었는가?



### 프로세스를 스케줄링 하기 위한 큐

- Job queue
- Ready queue
- Device queue
- Resource queue
  - 이러한 큐들이 프로세스 앞에 줄서 있고, 이것을 운영체제가 관리하는 것

![1570537703427](ewha-os.assets/1570537703427.png)

### 스케쥴러

- Long-Term Scheduler
  - 시작 프로세스 중 어떤 것들을 ready queue로 보낼지를 결정함.
  - 프로세스에 메모리(및 각종 자원)을 주는 문제를 결정
  - 우리가 사용하는 시스템(time sharing system)에서는 장기 스케쥴러가 없음....
    - 보통 시스템은 일단 실행되면 ready상태로 메모리에 올라감.

- Short-Term Scheduler
  - 어떤 프로세스를 다음번에 running 시킬지 결정하는 스케줄러
  - 프로세스에 CPU를 주는 문제를 결정

- Medium-Term Scheduler 
  - 중기 스케쥴러
  - 현재 대부분 우리가 사용하는 스케쥴러
  - 일단 프로그램을 메모리에 다 올려놓고, 너무 많은 프로그램이 메모리에 올라가있으면 적절하게 선정하여 쫒아냄.



### Thread

- 프로세스 내부에, **CPU 수행 단위**를 일컫는 말.

  - == lightweight process 

- 보통 프로세스 하나 주어지면, 몇가지 쓰레드가 있게됨.

  ![1570539015783](ewha-os.assets/1570539015783.png)

- 같은 일을 하는 프로세스를 여러개 하고 하고 싶으면, 주소공간을 하나, 메모리를 하나만 띄어놓고 PC만 여러개를 둠.

![1570539077847](ewha-os.assets/1570539077847.png)

- 레지지터에 위의 쓰레드들이 있음

- 프로세스 하나에서 공유할 수 있는 것은 최대한 공유하고, PC, registers, stack같은 것을 쓰레들간에 별도로 가지고 있는 것.



- 구성

  1. program counter

  2. register set
  3. stack space

- 동료 쓰레들과 공유하는 부분(=task)

  - code section
  - data section
  - OS resource

  ![1570539481728](ewha-os.assets/1570539481728.png)

  ![1570539528856](ewha-os.assets/1570539528856.png)

  

- 장점

  - 하나의 프로세스 안에 여러개의 쓰레드를 두게 되면, 하나의 쓰레드가 blocked 상태 일 때, 다른 쓰레드가 CPU를 잡고 Running 할 수 있음. 가볍게
    - 웹페이지를 읽어오는 동안에는 웹브라우저는 blocked 상태. 그렇게 되면 사용자 입장에서는 답답함. 왜 화면에 안보이니까.
    - 그러니까 여러개의 쓰레드를 통해 웹페이지를 읽게 되면 , 하나의 쓰레드가 일부만이라도 화면에 보여준다면 사용자에게 **빠른 응답성** 을 제공할 수 있게함.
  - 동일한 일을 수행하는 다중 쓰레드가 협력하면, **높은 처리율** 과 **성능향상** 을 얻음.



### Benefits of Threads

1. 응답성 Responsiveness
   - muti-threaded Web... 비동기식 입출력

2. 자원 공유 Resource Sharing
   - 하나의 수행을 별도의 프로세스를 통하기 보다는, 하나의 프로세스 안에 쓰레드를 나누는 것이 좀 더 효율적.
3. Economy
   - 프로세스를 하나 만드는 것보다, 하나의 쓰레드를 추가하는 것이 경제적이다(덜 오버헤드함.)
4. Utilization of MP Architectures



### Implementation of Threads

![1570539837791](ewha-os.assets/1570539837791.png)

- 커널 쓰레드
  - 운영체제가 여러 쓰레드가 있다는 것을 알고 있음.
  - 운영체제가 쓰레드를 넘기는 것을 도와줌
- 유저 쓰레드
  - 운영체제가 여러 쓰레드가 있다는 것을 모름
  - 사용자 수준에서, 라이브러리 도움을 받아서 쓰레드를 넘겨줌
- 리얼타임 쓰레드.



## 4. Process Management



### 프로세스 생성(Process Creation)

#### **COW** copy-on-write

- 일단 자식프로세스는 부모프로세스의 자원을 공유하다가, 자식 프로세스에서 변경사항이 생기면, 그러면 write하겠다.



- 부모 프로세스가 자식 프로세스를 생성(복제)할 수 있고.
- 프로세스는 운영체제로 부터 필요한 자원을 할당받고
- **기본적**으로는 부모, 자식 프로세스가 자원을 공유하지 않음.
  - 더 많은 자원을 얻기 위해 경쟁하는 형태가 많음.
- 수행(Execution)
  - 부모와 자식이 공존하면서 수행하는 모델
  - 자식이 종료terminate까지 기다리는 부모 모델도 있음.



- 어떻게 생성할까?
  - 복제생성
    - 부모 프로세스의 주소 공간을 자식 프로세스가 그대로 복사함
    - 부모 데이터들도 똑같이 복사.
    - 이렇게 복제된 곳에, 새로운 프로그램을 덮어씌우는 형식으로
  - **fork()** : 시스템 콜, 부모를 그대로 복사하는 과정
    - 시스템콜이면, 운영체제한테 자식을 만들어달라고 부탁하여 복사하는 방식
    - 즉 주체적으로 프로세스가 프로세스를 만드는 것은 아님.
  - **exec() : ** fork 다음에 이어지는 시스템콜로, 새로운 프로그램을 덮어씌우는 단계



1. 일단 복제해놓고,
2. 그래놓고 새로운 것을 덮어씌우는 방식

### 프로세스 종료(Process Termination)

- 프로세스가 마지막 명령을 수행한 후, 운영체제에게 이를 알려줌 **exit**
  - java `;` 는 컴파일시 exit 명령어를 실행하라고 말해주는 것

- 비 자발적으로 프로세스가 종료되는 경우? **abort**

  - 어떨때?

    1. 자식이 주어진 자원의 할당치를 넘어서면, 부모가 강제로 죽이는 것.

    2. 더이상 부모 프로세스가, 자식프로세스에게 실행시킬 일(task)이 없을 때

    3. 부모 프로세스가 종료되는 경우



### fork()

- 시스템 콜이고
- create a new address space that is a duplication of the caller

![1570965198076](ewha-os.assets/1570965198076.png)

- 좌측 부모, 우측 자식
- fork()가 실행되면 , 자식이 만들어졌을 때 fork()가 한 것 까지 기억을 해놨다가 다음 줄 부터 시작된다.
  - 어떻게 구분할까?
    - 부모 프로세스는 fork() 결과 값이 **양수!**
    - 자식 프로세스는 fork() 결과 값이 **0을** 받음



### exec()

- 시스템 콜

- replace the memory image of the caller with a new program

![1570965648466](ewha-os.assets/1570965648466.png)

- `execlp` 덮어씌우게 도와주는 명령어

![1570965822025](ewha-os.assets/1570965822025.png)

- 즉 `execlp` 이후에 있는 코드인 printf ... i am parent!는 실행이 되지 않는 코드이다. 절대로 돌아올 수 없음



### wait()

![1570965996093](ewha-os.assets/1570965996093.png)

- 프로세스를 잠들게 하는 것.
  - `block` 상태로 보내는 것. 
  - ex) I/O 작업

- 자식 프로세스 만든 다음에 사용하는 시스템 콜로, 자식 프로세스의 종료를 기다리며, 부모프로세스를 잠들게 하는 역할로 사용함.
  - 왜?
  - 자식이 종료될 때 까지 부모가 기다리는 모델을 위해



### exit() 

- 자발적인 종료
  - `}` 
  - `;`
  - 프로그램에 명시적으로 넣어주지 않아도 main함수가 리턴되는 위치에 컴파일러가 넣어줌
- 비자발적인 종료
  - 부모 프로세스가 자식 프로세스를 강제 종료시킴
  - `kill,break` 
  - 외부에서 종료시키는 경우
  - 부모 프로세스가 종료되는 경우
    - 본래 프로세스는 자식이 죽고, 부모프로세스가 종료되어야함
    - 그래서 부모 아래 있는 자식 프로세스를 모두 종료시키고, 부모 프로세스가 종료됨.



### 프로세스 간 협력

- 독립적 프로세스(Independent process)

  - 원칙적으로 하나의 프로세스는 다른 프로세스 수행에 영향을 미치지 못함

- 협력 프로세스(Cooperation process)

- 프로세스 간 협력 메커니즘(IPC : interprocess Commuication)

  1. 메세지를 전달하는 방법 : message passing(커널을 통해 메세지를 전달함)

     ![1570967624767](ewha-os.assets/1570967624767.png)

  2. 주소 공간을 공유

     - shared memory

       ![1570967763652](ewha-os.assets/1570967763652.png)

       - 일부 프로세스 공간을 공유함
       - 프로세스 b에다가 적으면, 프로세스 a도 공유된 공간을 통해 파악할 수 있을 것
       - 커널한테, shared memory를 쓴다고 call을 해야 사용할 수 있음

     - thread 

       - 한 프로세스 안에, 여러 thread 활동하는 것
       - 그러면 thread끼리는 완전한 협력이 가능할 것. 주소 공간 자체가 전체적으로 공유되기 때문에



## 5. CPU 스케쥴링

- CPU and I/O Burst in Program Execution

  ![1570967948583](ewha-os.assets/1570967948583.png)

  - 어떤 프로그램이든, CPU Bursts 와 I/O Burst가 반복되면서 실행된다.

### CPU-burst-Time의 분포

![1570968117593](ewha-os.assets/1570968117593.png)

- cpu를 짦게 쓰고, 빈도가 잦으면서, 중간에 I/O가 끼어드는 잡 = I/O bound job
- cpu를 길게 쓰면? = CPU bound job
- **여러 종류의 잡이 있기에**, CPU 스케쥴링이 필요하다.
  - I/O bound job은 interactive job이기 때문에 CPU를 잡아서 사람에게 줘야 이용자가 불편함을 느끼지 않을 것
  - CPU 스케쥴링은 즉 interactive job을 원활하게 하게 위함



### 프로세스의 특성 분류

1. I/O bound job(process)
   - 사람과 작업하는,
   - CPU를 길게 잡고 있기 보다는 짦게, 빈도수를 많이 잡으면서 I/O에 더 많은 시간을 투자하는 잡
2. CPU bound job(process)
   - **계산** 위주의 job

### CPU Scheduler & Dispatcher

- 스케쥴러
  - Ready 상태의 프로세수 중에 CPU를 줄 프로세스를 고르는 역할을 함
  - **운영체제 안**에서 CPU 스케쥴을 하는 기능을 담당

- 디스패쳐
  - 실제로 CPU를 주는 역할
  - Context switch(문맥 교환)을 통해 CPU 제어권을 선택된 프로세스에게 넘김



- 언제 필요할까? CPU 스케쥴링이?

  1. Running -> Blocked (ex) I/O작업으로 넘어간 경우)
  2. Running -> Ready (할당시간 만료 될 경우, timer interrrupt)
  3. Blocked -> Ready (I/O작업이 끝난 경우, 인터럽트를 걸어서 CPU를 넘겨줌)
  4. Terminate

  ![1570968637043](ewha-os.assets/1570968637043.png)

## 6. Process synchroniztion



### 프로그램적 해결법의 충족 조건

1. Mutual Exclusion (상호 배제)

- 어떤 프로세스가 critical section에 들어가있으면, 다른 프로세스는 들어가면 안됨.

2. Progress (진행)

- critical section에 아무런 프로세스가 없는 상태에서, 들어가고자 하는 프로세스가 있으면 critical section에 들어가도록 허락해줘야함

3. Bounded Waiting(유한 대기)

- 특정 프로세스가 critical section에 들어가려하는데, 마냥 기다리지 않도록 해야함.



### Algorithm 1

![1571138997828](ewha-os.assets/1571138997828.png)

- Process P0, P1이렇게 코드가 두가지 있다고 가정함. (같은 코드로)
- while문을 돌면서 체크함.
  - turn 어떤 프로세스 차례인가? 프로세스 0번,  프로세스 1번???
  - 0번차례가 아니면, while문을 돌면서 계속 기다림
- turn이 0이면, crtical section에 들어갔다나
- 나오면 turn을 1로 바꿔줘서 상대방 차례로 바꿔줌
- if 프로세스마다 critical section에 들어가고자 하는 빈도수가 다를 수 있음.
  - 그럼 상대방이 turn을 바꿔주지 않으면, 들어갈 수가 없음.
  - 즉 **2. Progress** 조건을 만족하지 않음.



### Algorithm2

![1571139297670](ewha-os.assets/1571139297670.png)

- flag 사용
- flag == true이면 critical section에 들어가고 싶은 의사표시
- 상대방의 플래그를 체크하고
- true이면 기다리고, 아니면 자신이 들어감
- 자신이 들어갔다가 나오면 자신의 플래그를 false로 바꿔줌

- 둘다 깃발만 들고 있지, critical section에 들어가지 않았으면 진행이 되지 않음. 즉 2번 조건을 만족하지 못함



### Algorithm3 (Peterson's Algorithm)

![1571139474865](ewha-os.assets/1571139474865.png)

- **flag, turn** 두가지를 사용함
- while문을 돌고있는 프로세스는 계속 flag , turn을 체크함. 상대방이 나올때까지 변할리가 없으니까. 그럼 *비효율적* -> Busy Waiting



### Synchonization Hardware

![1571139755707](ewha-os.assets/1571139755707.png)

- 문제는 프로세스가 쓰기와 읽기를 동시에 못하는 것. 그래서 이부분을 지원해주면 위의 문제가 해결됨.
- 하드웨어적으로 지원해줌

- 읽어서, 값을 변경해주는 atom하게 인스턱션을 지원해줌
- <u>들어갈 때 lock을 걸고, 빠져 나올 때 lock을 풀어줄 수 있게 코드가 간결</u>하게 바뀐다.



###  Semaphores

- 추상자료형
  - Object와 Operation으로 구성됨
  - 논리적으로 정의하는 거지, 실제로 구현된 것과는 다른 의미

- Semaphore S도 추상자료형

  - P,V연산으로 Operation을 구성함

  ![1571140044150](ewha-os.assets/1571140044150.png)

  - 프로그래머가 좀 더 간편하게, Lock을 사용할 수 있도록.
  - 그렇지만...

### Critical Section of n Processes

![1571140273950](ewha-os.assets/1571140273950.png)



- 세마포어를 획득할 수 없으면, 그 프로세스를 block하고,
- 이제 세마포어를 획득할 수 있으면 잠들어 있는 프로세스를 wakeup 함

![1571140398679](ewha-os.assets/1571140398679.png)

- L? 프로세스를 연결하는 리스트



### Implementation

![1571140418816](ewha-os.assets/1571140418816.png)

- 어떤 프로세스가 세마포어를 획득하려 하는데  S.value<0이면 즉 자원을 쓰고 있는 프로세스가 있으면, S.L에 이 프로스세를 연결해놓고 해당 프로세스를 block상태로 나둔다.

- 그리고 어떤 프로세스의 자원을 증가시켰는데 s.value <=이라는 것은 P operation에 들어갔었음. 즉 잠들어있을 것 그러면 프로세스를 세마포어 리스트에서 빼고, 그 프로세스를 깨운다.

- S.value < 0 ? 누군가가 세마포어를 획득하기 위해 기다리고 있다.
- 양수면 세마포어를 획득해서 프로세스가 진행중에 있다.
- S.value는 기다리고 있는 프로세스가 있는지 확인하는 용도

### Which is better?

![1571140723158](ewha-os.assets/1571140723158.png)



### Semaphore 종류

- 2가지 있음

![1571140808074](ewha-os.assets/1571140808074.png)



### Deadlock and Starvation

- Semaphore 사용시 주의해야할 점

![1571140886952](ewha-os.assets/1571140886952.png)

- S,Q를 획득해야함
- 그런데 P0, P1하나씩 쥐고 있으면서 자기것은 내놓지 않고 기다리고 있는 것 : **DeadLock..**
  - 멈춘것.
  - 어떻게 해결할까?
  - Q를 획득하려면 S부터 먼저 획득하도록 만들어주면 됨.

- Starvation
  - 무한히 다른 자원을 얻지 못해서 진행하지 못하는
  - Deadlock도 Starvation의 일종



### Synchronization Problem

1. Bounded-Buffer Problem

2. Reader-Writers Problem
3. Dining-Philosophers Problem



## 7. DeadLock

- 교착상태

- 일련의 프로세스들이 서로가 가진 자원을 기다리면서 Block된 상태
  - 자원(Resource)은 하드웨어일수도, 소프트웨어일수도 있음.



### Deadlock 발생조건 4가지

1. Multual exclusion 상호배제
   - 프로세스가 자원을 얻었으면 독점적으로 사용하고 있음
2. No preemption 비선점
   - 프로세스는 자원을 스스로 내어놓을뿐 강제로 빼앗기지는 않는다.
3. Hold and wait 보유 대기
   - 자원을 가진 프로세스가 다른 자원을 기다릴 때 보유 자원을 놓지않고 잡고 있음
4. Circular wait
   - 자원을 기다리는 프로세스간에 사이클이 형성되어야 함

- 시험문제에 잘나옴ㅎㅎ



### 자원할당 그래프

![1571748841241](ewha-os.assets/1571748841241.png)

- 프로세스에서 자원으로 가는 화살표 : 자원을 요청. 그러나 얻지는 못한 상태
- 자원에서 프로세스에게 가는 화살표 : 자원이 할당된 상태. 자원안에 점은 인스턴스 수임.
- 이 그래프가 데드락일까?

![1571748930928](ewha-os.assets/1571748930928.png)

- 좌측 그래프는 Deadlock 상태, 우측 그래프는 Deadlock상태가 아님
- Deadlock은 많이 발생하는 것은 아님.

### Deadlock 처리방법

![1571750090348](ewha-os.assets/1571750090348.png)



### Deadlock Prevention

- 데드락이 발생하는 4가지 조건의 원인을 원천적으로 차단함.

![1571749264574](ewha-os.assets/1571749264574.png)

### Deadlock Avoidance

- 프로세스가 시작될 때, 사용할 최대의 자원을 미리 알고있고 가용자원에 따라 자원할당을 관리함
  - 이를 이용해서 Deadlock을 피해감.
- 자원을 요청한다고해서 자원을 모두 내어주는 것이 아닌, 데드락의 가능성을 파악한 후에 자원을 내어준다.
- 아주 안전하게 가자. 데드락이 절대 발생하지 않도록!



#### Resource Allocation Graph algorithm

![1571749656966](ewha-os.assets/1571749656966.png)

- 점선 화살표 : 이 프로세스가 평생에 적어도 한번은 해당 자원을 사용할 가능성이 있음.

- 그래프 3번은 데드락 가능성이 있긴 함.

#### Banker's Algorithm

![1571749865835](ewha-os.assets/1571749865835.png)

- 최악의 경우만을 가정. 절대 Deadlock이 생기지 않으려고 함.
- 가용가능한 자원이, 최대요청 자원보다 커야만 프로세스의 자원요청을 받아들임.
  - P0 요청은 받아들이지 않을 것.
  - 그렇지만 P1의 최대 자원은 3 2 2 , 사용가능한 자원은 3 3 2 그러면 추가요청이 허용될것. 안전하게

### Deadlock Detection and Recovery

- 프로세스가 얼마나 자원을 사용할지 알필요는 없음.

![1571750945873](ewha-os.assets/1571750945873.png)

- 자원당 인스턴스 하나 일때 , 자원을 포함한 그래프, 자원을 뺀 프로세스만 나와있는 그래프.
  - 우측 그래프는 100% 데드락인 상황
- 데드락을 찾는 오버헤드는?
  - O(n^2)
  - **깊이우선 탐색**을 하면 사이클이 있는지 알아볼 수 있음



![1571751143958](ewha-os.assets/1571751143958.png)

- 데드락이 있는지 없는지 확인 할때는, **낙관적인** 접근을한다.

  1. 자원들이 반납된다고 가정(?)

     P0 B1개 반납될것이다, P2 3 0 3 반납될것이다. (더이상 자원 요청이 없는 프로세스들의 할당된 자원을 반납)

  2. 쌓고 쌓고 쌓아서, 자원 요청을 해결할 수 있다면

  3. 데드락이 없다고 말할 수 있음.

  ![1571751350830](ewha-os.assets/1571751350830.png)

  - 반납이 가능한 자원은 P0의 B 1개 밖에 없음.
  - 이 반납한 자원으로 프로세스의 요청을 만족시킬 수있는 경우의 수 없음.
  - 그럼 Deadlock



- 이렇게 데드락이 발견되면 Recovery를 해야함

- Recovery
  1. Process termination
     - Deadlock에 연루된 프로세스를 모두 사살
     - Deadlock에 연루된 프로세스를 하나하나 사살해보는 것
       - 하나 죽여보고, 데드락이 풀렸는지 확인해보고, 안 풀렸으면 다른 연루된 프로세스 죽이고.
  2. Resource Preemption
     - 비용을 최소화할 사살대상 선정
     - safte state 로 rollback 하여 process를 restart
     - Stravation 문제
       - 동일한 프로세스가 계속 사살대상으로 선정되면...
       - 어떤 친구가 얼마나 자원을 빼앗겼는지 고려해서 사살대상을 선정.

### Deadlock Ignorance

- Deadlock이 일어나든, 안 일어나든 아무일도하지 않는것.
  - 왜?
  - 데드락은 매우 드물게 발생.
  - 그러므로 데드락에 대한 조치 자체가 더 큰 overhead일수도있음.
  - 그래서 데드락이 발생하면 시스템이 대처하는 것이 아닌, 사용자가 대처하도록
  - 대부분의 Unix, Windows등이 이 방법을 사용하고 있음.

