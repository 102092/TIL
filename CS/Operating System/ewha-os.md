## 출처

- http://www.kocw.net/home/search/kemView.do?kemId=1046323



## 목표

- 운영체제는 컴퓨터 하드웨어 위에, 설치되는 필수적인 소프트웨어 계층
  - 어떻게 컴퓨터 운영에 있어 도움이 될것인가?



## 1. 운영체제란?

![1570104116901](ewha-os.assets/1570104116901.png)

- 기능은 뭐가있을까?

  1. 하드웨어랑 어떻게 교류할까?
  2. 소프트웨어랑, 사용자랑 어떻게 교류할까?

  - 이 두가지가 운영체제 과목을 배우는 목적.

- 즉 운영체제는 컴퓨터 시스템을 편하게 사용할 수 있게하는 목적을 가진다.

  - 컴퓨터자원을 **효율적으로 관리하게 도와주는 역할**을 하는 것이 운영체제

- **협의의 운영체제(커널)**

  - 좁은 의미의 운영체제

  - 항상 메모리에 상주하는 부분

- **광의의 운영체제**

  - 커널뿐만 아니라 각종 주변 시스템 유틸리티 포함

  

- 다수의 프로그램이, 메모리를 요구할 경우 어떻게 운영체제는 <u>자원을 할당</u>할 것인가?

  - 형평성 있는 자원 분배
  - 효율성 있는 자원 관리

- 운영체제는 하드웨어(프로세스, 기억장치) 자원뿐 아니라, 소프트웨어 자원(파일...)도 관리해야함



![1570104521077](ewha-os.assets/1570104521077.png)

- CPU는 굉장히 빠른 자원.
  - 프로그램마다 하나의 자원을 할당하는 행동을 반복함.
  - 그 행동이 너무 빨라서, 사람들이 이용할 때는 지연을 느끼지 못한다.



### 운영체제 분류

1. 동시 작업 가능 여부

- 단일 작업(과거 운영체제)
  - single tasking
- 다중 작업(현대적인 운영체제)
  - multi tasking
  - 유닉스, 윈도우즈, IOS...



2. 사용자의 수

- 단일 사용자
  - 단일 작업만 지원해주는 과거 운영체제..
  - MS-DOS, 
- 다중 사용자
  - 하나의 서버에서, 다중 계정을 통해 작업을 할 수 있는 운영체제
  - UNIX, NT server



3. 처리방식

- 일괄 처리(batch processing)

  ![1570105399350](ewha-os.assets/1570105399350.png)

  - 작업을 모아서 처리.
  - 과거 방식 , 이 때는 이게 가장 효율적이였음..



- 시분할(time sharing)

  ![1570105425550](ewha-os.assets/1570105425550.png)

  - 시간 별로 작업을 처리
  - 일괄 처리 보다는 **짦은 응답시간!**
  - 여러 작업을 수행할 떄, 컴퓨터 작업능력을, 일정시간 단위로 분할하여 사용할 때
  - 그러나 사용자가 많아지만, 일정시간이 늘어날 수 있음.
    - 목적은 여러사람이 이용할 수 있게, 자원을 효율적으로 배분하는 것

  

- 실시간(RealTime OS)

  - 실시간 == 시분할?? : Nope
  - deadline이 있어서, 정해진 시간 안에 결과가 나오는 것을 보장해주는 운영체제
  - 즉 특수한 목적을 가진 시스템에서 사용됨 ex) 원자로/ 공장제어, 미사일 제어, 반도체... 로보트 제어등등.
  - Hard realtime system 경성 실시간 시스템 == 무조건 지켜라
  - Soft realtime system 연성 실시간 시스템 == 시간을 지키지않으면, 치명적인 결과를 초래하진 않지만 이용하는 사람이 기분이 나쁠 수 있음..(넷플리스에서 실시간으로 영화를 볼때 )

  

### 생각할점

- 지금 사용하는 운영체제는 **다중 사용, 다중 작업, 시분할** 로 이루어지고 있다는 점.



### 용어

- Multitasking 
- Multiprogramming : 메모리에 여러 프로그램이 동시에 올라가는 것, 멀티태스킹이 되려면, 멀티 프로그래밍이 되어야하지만, 이 용어는 메모리 측면을 강조한 언어
- Time sharing : 멀티태스킹과 유사. 그렇지만 CPU쪽을 강조하는, CPU의 시간을 분할해서 사용한다는 의미.
- Multiprocess : 위와 유사함 



- Multiprocessor : 위 4개와는 조금 다름. 하나의 컴퓨터에 CPU가 여러개 붙어있는 의미.
  - 멀티 프로세서가 지원되고, CPU가 여러개 있음. 병렬적으로 시스템을 실행시킬 수 있음.



### 운영체제의 예

1. UNIX
   - 서버를 위한 운영체제
   - 코드 복잡 만들기 어려움. 왜? 어셈블리 언어(기계어에 가까운 언어)로 되어있어서.. 이 점을 대체하기 위해 C언어(고급 언어, 그러면서 기계어와 상당히 가까운 언어)를 만듬.
   - 다른 컴퓨터에 이식하기 쉬움. 왜? C언어로 작성되어있어서 컴파일 하면 다른 컴퓨터에서도 이해할 수 있게됨
   - 최소한의 커널(항상 메모리에 상주하는)
   - Linux...
2. MS Windows
   - 개인 컴퓨터 목적
   - 단일 작업, 단일 사용자 목적



### 운영체제의 구조

![1570106738172](ewha-os.assets/1570106738172.png)

- CPU 스케쥴링 : 누구한테 CPU 시간을 할당할까?... 짦은 시간 간격으로 시간을 줬다 뺐었다함.
- 메모리 관리 : 한정된 메모리를 어떻게 쪼갤까? 공평하게 ? 많이 쓰는 애한테 많이 줘야하나? 

- 파일 관리 : 디스크에 파일을 어떻게 보관할까?, 어떻게 하면은 Disk 헤드의 움직임을 최소화하면서 빠르게 요청을 처리할 수 있을까?

- 입출력 관리 : 각기 다른 입출력 장치와 컴퓨터 간에 정보를 어떻게 주고 받게 할까? 



## 2. System Structure & Program Execution

- 운영체제 설명에 앞서, 컴퓨터 하드웨어의 동작에 대한 강좌.

  

### 컴퓨터 시스템 구조

![1570191871323](ewha-os.assets/1570191871323.png)

- I/O ? input, output

- Memory : CPU의 작업공간, CPU는 <u>매클럭사이클 마다, 메모리에서 기계어를 읽어서 실행</u>시키게 됨

- DISK : I/O device 

  

  ![1570192126626](ewha-os.assets/1570192126626.png)

- registers
  
- PC : program conter , cpu가 실행시킬 다음 작업의 메모리 주소를 가지고 있음.
  
- 각 I/O device마다 컨트롤러가 붙어 있어서, 작은 CPU 역할을 하고 있음.

- local buffer? 각 device의 작업공간

- mode bit : cpu에서 실행시키는 것이 운영체제 인지 사용자 프로그램인지 구분

  CPU는 메모리하고만 일하니까.  I/O device에는 접근 안함. 

  - 그러면 Disk에서 읽어오라는 요청은 어떻게 처리함?
  - CPU가 직접 Disk에 접근하지 않고 device controller에게 하라고 시킴
  - 이 작업을 interrupt line을 통해

- timer : 특정 프로그램이 CPU를 독점하는 것을 막기 위함.

  - CPU에 프로그램을 넘겨줄 때, timer를 설정하고 넘겨주기 때문에, 이 제한 시간을 넘기면 cpu에게 interrupt 를 걸음.
  - CPU는 interrupt line을 체크하여, OS에게 권한을 넘겨서 다음 프로그램으로 작업이 넘어감.

- 프로그램일 실행하다가 I/O 요청이 오면?

  - controller가 interrupt를 걸고, CPU는 운영체제에게 넘어가고, 운영체제는 왜 interrupt가 걸렸는 지 확인하고, I/O 프로그램 때문이라는 것을 확인하고 CPU를 할당하고
  - 끝나면, interrupt이전 작업에게 다시 CPU에게 할당하고



- Mode bit
  - **0이면?** 운영체제가 cpu를 가지고 있을 때는, 모든 작업을 실행할 수 있게 되어있음.
  - **1이면?** 사용자 프로그램이 cpu를 가지고 있을 때는, **제한,한정된 작업 실행**
  - interrupt가 들어오면 mode bit은 자동으로 0으로 바뀌게 됨.
  - 왜 필요?
    - 사용자 프로그램의 잘못된 수행으로 다른 프로그램 및 운영체제에 피해가 가지 않도록 하기 위함
  - 모니터 모드?
    - ==커널모드, 시스템 모드
- Timer
  - 하드웨어
  - 특정 프로그램이 cpu를 독점하는 것을 막기 위해.
  - 정해진 시간이 흐른 뒤에 운영체제에게 CPU제어권이 넘어가도록 타이머를 걸어놓은 것



- Device Controller
  - I/O 장치를 관리하는 작은 CPU, 하드웨어 장치
  - local buffer 가짐 

- Device Driver
  - CPU가 실행하는 장치들을 작동시키지 위한 코드를 가지고 있음.



- DMA controller
  - Direct Memory Access Controller
  - 메모리에 접근할 수 있는 컨트롤러. 
    - 원래는 메모리에 접근할 수 있는 것은 CPU 단독이지만,
    - memory controller도 접근할 수 있기에, 중재하는 역할
  - 또한, 중간중간에 들어오는  cpu로 향한 interrupt가 될 작업들을 가지고 있다가 한번에 메모리에 올려 interrupt를 걸고 알려주는 역할



### 인터럽트

- 하드웨어가 거는 interrupt , **timer** , **I/O controller**
  - 일반적인 인터럽트
- 소프트웨어가 거는 interrupt : **trap**
  - System call, Exception...
- 인터럽트 벡터
  - 인터럽트 종류(**번호**)마다 어디에 있는 함수를 실행시켜하는 지 **주소**를 적어놓은 것
- 인터럽트 처리 루틴
  - 인터럽트 종류마다 할일이 다르니까. 이러한 일을 운영체제에 저장해 놨음



### 입출력

- 모든 입출력 명령은 특권 명령

  ![1570193782454](ewha-os.assets/1570193782454.png)

- 요청은 하드웨어 인터럽트를 통해, 요청이 다 끝나면 소프트웨어 인터럽트(트랩)

- 운영체제는 cpu를 사용할 일이 없음. 인터럽트가 들어올 때만 cpu운영권한을 얻지 그렇지 않으면 항상 사용자 프로그램만 돌리고 있음.



### 시스템 콜

- 사용자 프로그램이 운영체제의 서비스를 받기 위해 커널 함수를 호출 하는 것.
- 운영체제 함수를 호출하는 것. CPU제어권이 운영체제에게 넘어가게 하는 것.



### 동기식 입출력, 비동기식 입출력

- synchronous I/O

  - I/O 요청 후, 입출력 작업이 완료 된 후에야 제어가 사용자 프로그램에게 넘어감.

  ![1570194748972](ewha-os.assets/1570194748972.png)

  - I/O요청이 끝났음을 interrupt를 통해 알려줌.
  - 요청이 끝날 때 까지, 기다려야하는 방식
    - 그러면 자원이 낭비되지 않을까?
    - **보통 동기식 입출력을 구현**할 때, 방법 2를 사용함.

- asynchronous I/O
  - I/O가 시작된 후, 입출력 작업이 끝나기를 기다리지 않고 제어가 사용자 프로그램에게 넘어가는 것.
  - 요청이 끝나기 전에도, 다른 일을 시작하는 방식

- 예시

  ![1570194796176](ewha-os.assets/1570194796176.png)
  
  - 동기식 입출력 
    - 프로세스가 입출력 요청을 함 -> 운영체제 -> 컨트롤러
    - 입출력이 끝나는 동안 프로세스는 아무것도 안하면 **동기식 입출력**
  - 비동기식 입출력
    - 입출력이 끝나기 전에, 프로세스가 instruction을 실행하게 되면 비동기식 입출력.

### 서로 다른 입출력 명령어

![1570195271461](ewha-os.assets/1570195271461.png)

- 왼쪽

1. 메모리 접근하는 명령어
2. I/O device에 접근하는 명령어



- 오른쪽

1. I/O장치도, 메모리 주소에 연장주소를 붙인다음에 메모리 접근하는 명령어를 통해 접근 할 수 있게함.
   - Memory mapped I/O



- 왜 다르게 했을까?



### 저장장치 계층 구조

![1570195367918](ewha-os.assets/1570195367918.png)

- 특징 : 위로 갈 수록 속도가 빠름. 
  - 그렇지만 가격도 비싸고, 용량이 작음.
- 연두색 : 휘발성 매체
  - 분홍색 : 비휘발성 매체
- byte 단위 접근할 수 있는 Primary, Executable한
  - CPU에 직접 접근하지 못하는 개체 : Secondary

- Caching : 다른 매체를 통해 데이터를 읽어서 사용하는 것.
  - 그렇지만 밑에서 모든 것을 다 읽진 못함. 위로 갈수록 용량이 작아지니까.. 
  - 이것을 어떻게 관리해야 되는지가 포인트.



### 프로그램의 실행 (메모리 load)

![1570195644592](ewha-os.assets/1570195644592.png)

1. 파일시스템 : 실행파일
2. virtual memory
   - code : 기계어
   - data : 자료구조
   - stack : 함수를 호출할 때 데이터를 쌓는 용도
3. 프로세스로



- virtual memory에 있는 것을 모두 다 physical memory에 올리는 것이 아니라 , 필요한 일부분만 올림. 메모리를 효율적으로 사용하기 위해서
- 꼭 필요하지 않은 부분은 Swap area에 내려놓음.
- 즉 그림에 보이는 것처럼 Virtual memeory에 모여있는 것이 아니라, 일부분은 Physical memory에 일부분은 Swap area에 있음.

- Swap area : 휘발성. 메모리 관리를 위한 공간.
- File system : 비휘발성. 파일 관리를 위한 공간.



### 커널 주소 공간 내용

![1570195895746](ewha-os.assets/1570195895746.png)

- process controller block
- 사용자 프로그램마다 따로 커널 스택을 가지고 있음.



### 사용자 프로그램이 사용하는 함수

- 함수
  - 사용자 정의함수
  - 라이브러리 함수
  - 커널 함수
    - 운영체제 프로그램의 함수
    - 커널 함수가호출되는 것은 시스템 콜을 의미한다.

![1570196128928](ewha-os.assets/1570196128928.png)

- 프로스세 A의 address space에서 Kenel Address space로 점푸하지는 못함.



### 프로그램의 실행

![1570196218982](ewha-os.assets/1570196218982.png)

- 유저모드에서 실행이 됨.
- 시스템 콜을 하게 되면, 운영체제 커널 주소 공간에 있는 코드가 실행되고
- 시스템 콜이 끝나게 되면, A라는 프로그램에게 CPU제어권이 넘어가고, 
- 본인 코드 주소에 있는 코드를 실행하게 됨.
- 즉 프로그램의 실행은 유저 <-> 커널 모드 하면서 실행됨을 알 수 있음.



## 3. 프로세스

- program in execution

  - 실행중인 프로그램을 일컫는 말.

- 프로세스의 문맥

  - 특정 시점을 놓고 봤을 때, 어디까지 수행을 했고 어디까지 와있는가?
    - 이게 왜 필요해? 연속되어 실행될 수 있게 하려고...?

  1. 하드웨어 문맥  : 레지스터가 어떤 값을 가지고 있는가?
  2. 프로세스의 주소 공간 : code, data, stack에 어떤 값이 들어가 있는가?
  3. 프로세스 관련 커널 자료 구조 : PCB(Process Control Block)



### Process State 

- 컴퓨터 내부에 CPU는 1개로 정의

1. Running
   - CPU를 잡고, instuction을 수행 중인 상태
2. Ready
   - CPU를 잡기 위해 대기하고 있는 상태
   - 다른 모든 준비는 끝나있고, CPU만 얻기를 기다리고 있음. 보통 이 상태에 있는 프로그램들이 CPU를 잡았다 놨다 하면서 실행됨.
3. Blocked
   - CPU를 주어도 당장 instruction이 불가능한 상태 (= 시간이 오래걸리는 I/O 작업들)
4. Suspended
   - CPU뿐만 아니라, 외부에서 이 시스템을 강제로 정지해놓은 상태
   - **중기 스케쥴러**와 함께 알아야한 프로세스의 상태

5. etc

   - new : 프로세스가 생성중인 상태

   - terminated : 수행이 끝났음. 그렇지만 정리가 필요한 상태

   

- Blocked 는 자기 자신이 요청한 상태, event가 만족되면 Ready상태로 돌아감
- Suspended는 반면여, 외부에서 요청한 상태로, 외부에서 resume을 해줘야 Active함

6. 프로세스 상태도

![1570536775043](ewha-os.assets/1570536775043.png)

​	

![1570536856956](ewha-os.assets/1570536856956.png)

- 프로세스가 디스크에서 무언가 읽어야 한다? Running 상태에서 blocked상태로 변함
  ![1570538366564](ewha-os.assets/1570538366564.png)

  - 사용자모드에서 코드 실행 중인 상태

  - 프로세스가 자기 코드를 실행하다가, 콜해서 운영체제 코드가 실행 중이면 이 프로세스가 커널모드에서 run하고 있는 상태라고 부름

  - interrupt 해서, 운영체제 코드가 실행 중이면, monitor mode에 들어갔다고 함.

    ​	![1570538576703](ewha-os.assets/1570538576703.png)

  - 점선 아랫 부분은 inactive한 상태. 외부에서 간섭으로 인해서. 프로세스가 얼어붙어있는 상태

  

### Context Switch

- CPU가 한 프로세스에서 다른 프로세스로 넘겨주는 과정을 일컫는 말.

  ![1570537231834](ewha-os.assets/1570537231834.png)

- CPU를 뺐었으면,운영체제가 프로세스가 다시 실행될 때 어디까지 실행되었는 지 기억할 수 있도록 함.
- 어디에다가? 실행되고 있던 프로세스의 **PCB**에다가!

- System call : 운영체제가 CPU에게 요청하는 것

- Interrupt : 하드웨어 , 컨트롤러가 CPU에게 거는 것

  - System call, Interrupt가 발생시 반드시 context switch가 일어나는 것은 아님.

  ![1570537437586](ewha-os.assets/1570537437586.png)

  - 1번 은 문맥교환 아니고, 2번은 문맥교환임.
  - 차이는 중단된 프로세스가 interrupt of system call 이후에 그대로 지속되었는가?
  - 즉 프로세스 자체가 바뀌었는가?



### 프로세스를 스케줄링 하기 위한 큐

- Job queue
- Ready queue
- Device queue
- Resource queue
  - 이러한 큐들이 프로세스 앞에 줄서 있고, 이것을 운영체제가 관리하는 것

![1570537703427](ewha-os.assets/1570537703427.png)

### 스케쥴러

- Long-Term Scheduler
  - 시작 프로세스 중 어떤 것들을 ready queue로 보낼지를 결정함.
  - 프로세스에 메모리(및 각종 자원)을 주는 문제를 결정
  - 우리가 사용하는 시스템(time sharing system)에서는 장기 스케쥴러가 없음....
    - 보통 시스템은 일단 실행되면 ready상태로 메모리에 올라감.

- Short-Term Scheduler
  - 어떤 프로세스를 다음번에 running 시킬지 결정하는 스케줄러
  - 프로세스에 CPU를 주는 문제를 결정

- Medium-Term Scheduler 
  - 중기 스케쥴러
  - 현재 대부분 우리가 사용하는 스케쥴러
  - 일단 프로그램을 메모리에 다 올려놓고, 너무 많은 프로그램이 메모리에 올라가있으면 적절하게 선정하여 쫒아냄.



### Thread

- 프로세스 내부에, **CPU 수행 단위**를 일컫는 말.

  - == lightweight process 

- 보통 프로세스 하나 주어지면, 몇가지 쓰레드가 있게됨.

  ![1570539015783](ewha-os.assets/1570539015783.png)

- 같은 일을 하는 프로세스를 여러개 하고 하고 싶으면, 주소공간을 하나, 메모리를 하나만 띄어놓고 PC만 여러개를 둠.

![1570539077847](ewha-os.assets/1570539077847.png)

- 레지지터에 위의 쓰레드들이 있음

- 프로세스 하나에서 공유할 수 있는 것은 최대한 공유하고, PC, registers, stack같은 것을 쓰레들간에 별도로 가지고 있는 것.



- 구성

  1. program counter

  2. register set
  3. stack space

- 동료 쓰레들과 공유하는 부분(=task)

  - code section
  - data section
  - OS resource

  ![1570539481728](ewha-os.assets/1570539481728.png)

  ![1570539528856](ewha-os.assets/1570539528856.png)

  

- 장점

  - 하나의 프로세스 안에 여러개의 쓰레드를 두게 되면, 하나의 쓰레드가 blocked 상태 일 때, 다른 쓰레드가 CPU를 잡고 Running 할 수 있음. 가볍게
    - 웹페이지를 읽어오는 동안에는 웹브라우저는 blocked 상태. 그렇게 되면 사용자 입장에서는 답답함. 왜 화면에 안보이니까.
    - 그러니까 여러개의 쓰레드를 통해 웹페이지를 읽게 되면 , 하나의 쓰레드가 일부만이라도 화면에 보여준다면 사용자에게 **빠른 응답성** 을 제공할 수 있게함.
  - 동일한 일을 수행하는 다중 쓰레드가 협력하면, **높은 처리율** 과 **성능향상** 을 얻음.



### Benefits of Threads

1. 응답성 Responsiveness
   - muti-threaded Web... 비동기식 입출력

2. 자원 공유 Resource Sharing
   - 하나의 수행을 별도의 프로세스를 통하기 보다는, 하나의 프로세스 안에 쓰레드를 나누는 것이 좀 더 효율적.
3. Economy
   - 프로세스를 하나 만드는 것보다, 하나의 쓰레드를 추가하는 것이 경제적이다(덜 오버헤드함.)
4. Utilization of MP Architectures



### Implementation of Threads

![1570539837791](ewha-os.assets/1570539837791.png)

- 커널 쓰레드
  - 운영체제가 여러 쓰레드가 있다는 것을 알고 있음.
  - 운영체제가 쓰레드를 넘기는 것을 도와줌
- 유저 쓰레드
  - 운영체제가 여러 쓰레드가 있다는 것을 모름
  - 사용자 수준에서, 라이브러리 도움을 받아서 쓰레드를 넘겨줌
- 리얼타임 쓰레드.