## 1.4 응답과 처리량

- 응답 : 요청에 얼마나 빠르게 반응할 수 있는지를 의미
- 처리량 : 처리할 수 있는 양이 많은 지를 의미.

- 한명이 하나의 짐을 나를때 걸리는 시간이 10초라 가정하자
  - 이 얘기는 응답 시간이 10초
  - 처리량은 한번에 1개 라고 생각 할 수 있음.
  - 그러다가 두 명이 짐을 나르도록 만든다 --> 즉 CPU 코어수를 늘렸다.
    - 응답시간은 10초(여전히 같은 응답시간을 보여준다)
    - 그렇지만 처리량은 2배가 되었다!

- 응답이 빠르면, 보통 처리량도 올라간다.



## 1.5 알고리즘의 구체적인 예

### 배열과 루프 처리

- 배열은 상자가 일정 수만큼 나열돼 있는 것.
- 배열의 계산량은 `O(n)`
- 장점은 반복 처리와 궁합이 좋다!
- 단점은 배열은 길이를 미리 알 수 없기 때문에, 영역이 낭비되거나 부족할 수 있음.



### 리스트와 루프 처리

- 체인과 같은 구조
- 배열과의 차이점은, 배열에서는 상자가 연결되어 있어 서로 분리할 수 없지만, **리스트 구조는 줄 같은 것으로 연결**되어 있다!
- 장점은 유연성! 데이터를 넣고 싶은 곳에 넣을 수 있다. 
  - 즉 배열처럼 다른 데이터를 복사-이동할 필요없음!
  - 다시 생각해보면, 데이터 추가 변경이 잦은 경우 리스트를 사용해야한다!
- 단점은 주소를 통해 바로 접근하기 어렵다
- 양방향 리스트



### 트리와 검색

- 트리는 데이터를 검색하는 경우 많이 사용된다.
- 하나의 접점, 종점을 노드라 부린다.
- 계산량은 `O(logn)`
  - 데이터가 증가할 수록 처리량이 완만하게 증가
- 장점은 관계없는 데이터는 보지 않고 처리가 가능하다
- 단점은 데이터 갱신에 약하다, 그리고 같은 데이터만 들어올시 한쪽 가지만 늘어날 수 있다--> 비효율적이 된다.
- 2분트리, B 트리, B+트리



### 해시 알고리즘

- 한번의 계산만으로 데이터를 찾아 낼 수 있는 특성을 가졌음
- 데이터 수와 같거나, 그보다 큰 배열을 준비한 후 -> 각 데이터에 대해 Hash 계산을 해서 데이터를 저장할 위치를 결정
- 계산량 `O(1)`
- 장점은 데이터가 아무리 늘어나도 검색 시간에는 변화가 없다. 무조건 `O(1)` 
- 단점 `Collision` , 어떠한 데이터들이 동일한 해시 값이 되는 경우
  1. 리스트 구조로 해결하거나 
  2. Rehash한다
- 리스트 구조의 경우, 최악의 경우 `O(n)` 이 걸릴 수 있음.



### 큐

- FIFO : First In First Out
- 계산대에서 순서를 기다리거나, 은행에서 순서를 기다리는 구조가 큐임.
  - DB에 대한 처리나, 접속 요구
  - 네트워크, I/O
  - CPU 대기...
- 계산량은 보통 `O(1)`
- 장점 : 접속 처리등을 처리할 때 유용
- 단점 : 큐는 무한대가 아니므로, 넘칠 수 있음 , 또한 큐에 담겨진 요청사항이 유실될 수도 있다



### 스택

- FILO : First In Last Out
- 장점 : 필요한 만큼 공간을 사용하기 때문에 공간이 단편화 되지 않는다.
  - 단편화? 데이터가 특정 곤가으로 치우쳐저 저장되어 있는 상태를 말한다
- OS가 프로그램을 실행할 때에는 이 구조를 사용한다.
  - 이 때문에 메모리 영역을 낭비하지 않고, 여러 함수들을 호출하여서 처리할 수 있다!
- 계산량 보통 `O(1)`
- 단점 : 보통 적용할 수 있는 곳이 그렇게 많지 않다.
- Java VM의 스레드 덤프에서 나오는 스택 추적은 특정 함수가 어떤 함수를 호출하는지 스택을 그대로 보여주는 것!



### 퀵 소트

![](https://gmlwjd9405.github.io/images/algorithm-quick-sort/quick-sort2.png)

1. 숫자중에 가운데 정도의 숫자를 골라서
2. 배열의 왼쪽에는 해당 pivot 보다 작은수, 오른쪽에서는 큰 수가 오도록 배치
3. 각각 왼, 오른쪽 파트에 있는 숫자들을에 대해 1,2번과 동일한 처리를 반복

- 퀵 소트는 트리 구조를 위에서부터 만들어가는 형태



- 계산량은 평균적으로 `O(nlogn)`

  ![](https://gmlwjd9405.github.io/images/algorithm-quick-sort/sort-time-complexity.png)

- 장점은 데이터 검색 속도 향상

- 단점은 소트 자체에 시간이 좀 걸린다. 즉 일회성 검색이라면 별로 좋지 않음.



### 캐시[라이트백(write back)]

- 
- 
- 
- 캐시라는 것은 몰래 놓아둔다는 의미.
- 성능향상을 목적으로 사용됨.
  - CPU도 캐시를 가지고 있음. 메인 메모리나 디스크와 데이터 교환 시간을 줄이기 위해서 사용함
- 라이트백(write back)
  - 데이터 갱신 방식
  - 데이터를 갱신할때 정식 데이터를 갱신하지 않고, **캐시 데이터** 만 갱신했다가 나중에 정식 데이터를 갱신하는 방법
  - 장점 : 속도가 빠르다
  - 단점 : 정식 데이터와 불일치 문제가 발생할 수 있다



### 캐시[라이트스루(write through)]

- 시간은 걸리지만 데이터를 확실하게 갱신할 필요성이 있을 때 사용하는 방법
- 장점 : 캐시에 데이터가 있으면 읽기 처리가 빠르고, 쓰기 처리도 보장됨.
- 단점 : 캐시에 없을 경우, 정식 데이터에 기록하기 까지 시간이 걸리기 때문에 응답이 늦어질 수도 있음.



### 락과 성능

- 락은 병렬로 처리할 때 필요한 메커니즘.
- 락은 특정 처리가 진행되고 있을 때, 상태를 보호하기 위한 구조. 
  - 즉 다른 처리가 끼어들지 못하도록 만들어줌
- 락 대기 문제를 어떻게 해결할 수 있을까?
  - 기본적인 해결책은 락이 된 처리를 빨리 끝내는 것!
    - 즉 처음에 테이블에 락이 걸려있었다면, 좀 더 작게 나눠서 SQL에 락이 걸리도록 만들면 처리시간이 줄어들 것

- 다시 말해, 테이블에 락을 거는 것 보다는 레코드에 대해 락을 걸어서 SQL을 발행하면 병렬 실행이 가능하도록 만들 수 있다. 
- 락 단위를 작게 만들자
- 아토믹 atomic : 성공 또는 실패 둘 중에 하나만 있는 처리

