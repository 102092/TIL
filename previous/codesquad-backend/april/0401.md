## 0401

> done

- 알고리즘
  - [x] leetcode 1
- 강의

  - [x] 스프링 부트 1
  - [x] 호눅스 수업 정리 - > Notion
  - [x] spring data jdbc 유투브 강의 정리하기


> todo

- 알고리즘

  - [ ] prgr 1

- 강의

  - [ ] JK 수업 정리

- book

  - 데이터베이스 첫걸음
    - [ ] 10ch

- CS

  - [ ] 운영체제 정리하기 1ch Notion
  - [ ] 더 자바 Notion
  - [ ] 서버 hup / sighup 터미널 백그라운 프로세스, 시그널 
    - avanced unix system programming 

  

  

  





> dust-11

- 이전
  - [ ] 저번주 풀리퀘 살펴보기



> JK class

### OOP

- 패러다임
- 객체 중심 프로그래밍 패러다임
- 서양 사람들이 오브젝트에 대해서 어떻게 생각하는지, 프로그래밍 세계에서 객체가 어떻게 구성되는지



#### 객체

- 나 이외, 화자 이외의 모든 사물을 객체라고 함.
- 객체는 본질, 현상으로 나뉜다.
  - 본질은 클래스
  - 현상은 인스턴스
- 객체가 무엇인가?
  - 클래스 코드와 인스턴스가 합쳐진 것을 객체라 부른다.
  - 객체는 **속성**과 **행위**를 둘 다 가지고 있어야함.
- 옛날 프로그램은의 메모리에는 데이터, 코드가 혼재되어 있었음. 그래서 순차적인 실행만 가능했다. 
  - 어떤것이 값이고 행위인지 구분이 안되었음.

#### 프로그래밍 패러다임

- 구조적 프로그래밍 : 제어 흐름의 직접적인 전환에 부과하는 규칙
- 객체지향 프로그래밍 : 제어 흐름의 간접적인 전환에 부과하는 규칙
- 함수형 프로그래밍 : 변수 할당에 부과하는 규칙



#### 왜 객체지향 프로그래밍이 먼저 발전?

- GUI 프로그래밍의 등장으로, Copy and Paste...
- 앨런 케이 : small talk (OOP)
  - 관련있는 데이터를 놓고, 관련있는 프로시저를 붙여놓고 같이 표현해야 의미있는 단위가 된다.
  - OOP의 시초.



#### 추상 데이터 타입 vs 객체 지향

- 추상 데이터 타입은 수평적으로, Ruby
- 객체 지향에서는 수직적으로, 데이터를 객체 단위로 속성과 행위.



#### 다형성

- 상속을 통해서 이뤄짐.
- super class (추상화) --> 하위 클래스(구체화)
  - 상위 클래스에서 정의된 메서드를 하위 클래스에서 재정의하면, 어떤 인스턴스에서 호출되는지에 따라서 다른 의미로 움직인다.
- 인터페이스 상속을 써라
  - 인터페이스로 추상해놓고 그것을 구현하는 방식
  - 인터페이스로 클래스를 확장하는 방법.
  - 왜?
  - duck type 



#### 클래스, 데이터 타입

- 클래스를 만드는 이유는 **타입** 으로 쓰기 위해서.
- 어떤 타입이냐?
  - 인터페이스interface 타입인지, 구체concrete 타입인지, 추상abstract 데이터 타입인지 구분해서 써야함.
- 보통 최상위 레벨에 type은 시스템에서 준다.
  - 개발자는 가장 아래서 조금씩 타입을 만들어 간다고 보면됨.



#### 캡슐화

- 클래스를 만들어서 정보 감추고 기능을 부여하는 것.
- 클래스에 있는 값을 외부에서 접근할 수 있는 것을 불안전하다고 함.
  - 접근자를 private으로 바꾸자.
- 그리고 객체 속성끼리 비교하지말고, **객체 자체를 비교하려고 하자**
- 값들이 중요하면 해쉬값으로 비교한다거나.
- 하위클래스는 복잡한 일을 하고, 상위클래스는 그 일을 하기만하면됨.
  - 값을 가져오려고 하지말고, 일을 시키려하자.



#### 응집도

- 관련 있는 것끼리 얼마나 묶어 놓는가? 를 의미하는 것.
- 응집도가 높은 상태로 클래스를 만들면, 한 가지 큰 덩어리 책임만 가지고 있도록 구현해 놓은 클래스를 단일 책임 원칙을 잘 지킨다고 함.
- 함수가 단일 책임을 갖게 하려면 어떡해야할까?



#### 열림-닫힘 원칙 -OCP

- 인터페이스를 쓰면 OCP 원칙을 조금 접근하게 됨.
- 열거 타입을 쓰면, 열거 타입을 쓰는 곳곳 마다 스위치 문이 생김.
- 언제 열거 타입을 쓸까?
  - Data만 있고, Behavior를 갖지 않은 경우. 즉 행위가 없다.
  - 객체는 행위(로직)을 갖고 있음.
  - 그렇지만 DTO data transfer object와 같은 애들은 객체가 아니다.
  - 로직이 있을 때, 의미있는 설계 패턴이 필요한 것.

- OCP를 잘 구현하려면, 구체화된 타입에 의존하지 않고, 추상화된 인터페이스에 의존해야함.



#### 인터페이스 분리원칙 -LSP

- 인터페이스도 역할에 따라서 나눠서 해야함



#### 의존성 역전 원칙 - DIP

- player가 cardeck에 의존.
  - player가 cardect 메서드를 사용하기 때문에 의존하기도 하고
  - player가 cardect을 생성하기 때문에
- 의존성 역전은 생성을 내가 하지 않고, 상위 모듈에서 생성을 함.
- 시스템 프레임워크 에서 만들어준 객체는 의존적이지 않다고 생각함.
  - String 을 쓰는 것도 의존적인 것.
  - 원래는 의존적이지만
- 객체 내부 변수들은 인터페이스로 대체할 수 있는 지 생각해보자.



#### 도서

- 오브젝트 좋음.

- 객체 끼리 통신을 생각하자.



#### 구현을 통한 검증

- 메세지 응답에 필요한 우선 메서드를 추가하고
- 이러한 메서드에 필요한 인스턴스 변수를 추가하고
- 그리고 책임에 필요한 내용을 구현해주면 됨.



#### 단일 책임 원칙 SRP

- 응집도가 단일 책임 원칙을 만들어라.
- 응집도를 어떻게 판단함?
  - 인스턴스를 초기화 하는 시점에서 모든 변수들이 초기화 되는지.
- 다형성을 적용하면 분기문을 없앨 수 있음.



#### 명령-쿼리 분리 원칙

- 프로시저 : 부수효과를 발생할 수 있지만, 값을 반환할 수는 없다.
- 함수 : 값을 반환할 수는 있지만, 부수효과를 발생시킬수는 없다.